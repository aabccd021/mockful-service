/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/products": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List products
     * @description Returns a paginated list of products. Use the query parameters to page through results.
     *
     *     By default, Paddle returns products that are `active`. Use the `status` query parameter to return products that are archived.
     *
     *     Use the `include` parameter to include related price entities in the response.
     */
    get: operations["list-products"];
    put?: never;
    /**
     * Create a product
     * @description Creates a new product.
     *
     *     Paddle does not upload product images to a CDN. For `image_url`, you should host images on an HTTPS server that's publicly accessible. We recommend using square images (`1:1` ratio).
     *
     *     If successful, your response includes a copy of the new product entity.
     */
    post: operations["create-product"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/products/{product_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the product entity to work with. */
        product_id: components["parameters"]["product_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a product
     * @description Returns a product using its ID.
     *
     *     Use the `include` parameter to include related price entities in the response.
     */
    get: operations["get-product"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a product
     * @description Updates a product using its ID.
     *
     *     Paddle does not upload product images to a CDN. For `image_url`, you should host images on an HTTPS server that's publicly accessible. We recommend using square images (`1:1` ratio).
     *
     *     If successful, your response includes a copy of the updated product entity.
     */
    patch: operations["update-product"];
    trace?: never;
  };
  "/prices": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List prices
     * @description Returns a paginated list of prices. Use the query parameters to page through results.
     *
     *     By default, Paddle returns prices that are `active`. Use the `status` query parameter to return prices that are archived.
     *
     *     Use the `include` parameter to include the related product entity in the response.
     */
    get: operations["list-prices"];
    put?: never;
    /**
     * Create a price
     * @description Creates a new price.
     *
     *     Prices describe how you charge for products. You must include a `product_id` in your request to relate this price to a product.
     *
     *     If you omit the `quantity` object, Paddle automatically sets a minimum of `1` and a maximum of `100` for you. This means the most units that a customer can buy is 100. Set a quantity if you'd like to offer a different amount.
     *
     *     If successful, your response includes a copy of the new price entity.
     */
    post: operations["create-price"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/prices/{price_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the price entity to work with. */
        price_id: components["parameters"]["price_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a price
     * @description Returns a price using its ID.
     *
     *     Use the `include` parameter to include the related product entity in the response.
     */
    get: operations["get-price"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a price
     * @description Updates a price using its ID.
     *
     *     If successful, your response includes a copy of the updated price entity.
     */
    patch: operations["update-price"];
    trace?: never;
  };
  "/transactions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List transactions
     * @description Returns a paginated list of transactions. Use the query parameters to page through results.
     *
     *     Use the `include` parameter to include related entities in the response.
     */
    get: operations["list-transactions"];
    put?: never;
    /**
     * Create a transaction
     * @description Creates a new transaction.
     *
     *     Transactions are typically created with the status of `draft` or `ready` initially:
     *
     *     * Draft transactions have `items` against them, but don't have all of the required fields for billing. Paddle creates draft transactions automatically when a checkout is opened.
     *     * Paddle automatically marks transactions as `ready` when all of the required fields are present for billing. This includes `customer_id` and `address_id` for automatically-collected transactions, and `billing_details` for manually-collected transactions.
     *
     *     The `collection_mode` against a transaction determines how Paddle tries to collect for payment:
     *
     *     * Manually-collected transactions are for sales-assisted billing. Paddle sends an invoice to your customer when a transaction is `billed`. Payment is often by wire transfer.
     *     * Automatically-collected transactions are for self-serve checkouts. You may pass the transaction to a checkout or use the returned `checkout.url` to collect for payment.
     *
     *     When a manually-collected transaction is marked as `billed` or an automatically-collected transaction is `completed`, Paddle automatically creates a related subscription for the items on the transaction.
     *
     *     If successful, your response includes a copy of the new transaction entity.
     *
     *     Use the `include` parameter to include related entities in the response.
     */
    post: operations["create-transaction"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/pricing-preview": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Preview prices
     * @description Previews calculations for one or more prices. Typically used for building pricing pages.
     *
     *     You can provide location information when previewing prices. You must provide this if you want Paddle to calculate tax or [automatically localize prices](https://developer.paddle.com/build/products/offer-localized-pricing). You can provide one of:
     *
     *     * `customer_ip_address`: Paddle fetches location using the IP address to calculate totals.
     *     * `address`: Paddle uses the country and ZIP code (where supplied) to calculate totals.
     *     * `customer_id`, `address_id`, `business_id`: Paddle uses existing customer data to calculate totals. Typically used for logged-in customers.
     *
     *     If successful, your response includes the data you sent with a `details` object that includes totals for the supplied prices.
     *
     *     Each line item includes `formatted_unit_totals` and `formatted_totals` objects that return totals formatted for the country or region you're working with, including the currency symbol.
     *
     *     You can work with the preview prices operation using the [`Paddle.PricePreview()`](https://developer.paddle.com/paddlejs/methods/paddle-pricepreview) method in Paddle.js. When working with `Paddle.PricePreview()`, request and response fields are `camelCase` rather than `snake_case`.
     */
    post: operations["preview-prices"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/preview": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Preview a transaction
     * @description Previews a transaction without creating a transaction entity. Typically used for creating more advanced, dynamic pricing pages where users can build their own plans.
     *
     *     Consider using [the preview prices operation](https://developer.paddle.com/api-reference/pricing-preview/preview-prices) for simpler pricing pages.
     *
     *     You can provide location information when previewing a transaction. You must provide this if you want Paddle to calculate tax or [automatically localize prices](https://developer.paddle.com/build/products/offer-localized-pricing). You can provide one of:
     *
     *     * `customer_ip_address`: Paddle fetches location using the IP address to calculate totals.
     *     * `address`: Paddle uses the country and ZIP code (where supplied) to calculate totals.
     *     * `customer_id`, `address_id`, `business_id`: Paddle uses existing customer data to calculate totals. Typically used for logged-in customers.
     *
     *     When supplying items, you can exclude items from the total calculation using the `include_in_totals` boolean.
     *
     *     By default, recurring items with trials are considered to have a zero charge when previewing. Set `ignore_trials` to `true` to ignore trial periods against prices for transaction preview calculations.
     *
     *     If successful, your response includes the data you sent with a `details` object that includes totals for the supplied prices.
     *
     *     Transaction previews don't create transactions, so no `id` is returned.
     */
    post: operations["preview-transaction-create"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/{transaction_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the transaction entity to work with. */
        transaction_id: components["parameters"]["transaction_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a transaction
     * @description Returns a transaction using its ID.
     *
     *     Use the `include` parameter to include related entities in the response.
     */
    get: operations["get-transaction"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a transaction
     * @description Updates a transaction using its ID.
     *
     *     You can update transactions that are `draft` or `ready`. `billed` and `completed` transactions are considered records for tax and legal purposes, so they can't be changed. You can either:
     *
     *     * Create [an adjustment](https://developer.paddle.com/api-reference/adjustments/overview) to record a refund or credit for a transaction.
     *     * Cancel a `billed` transaction by sending a PATCH request to set `status` to `canceled`.
     *
     *     The transaction `status` may only be set to `billed` or `canceled`. Other statuses are set automatically by Paddle. Set a manually-collected transaction to `billed` to mark it as finalized. This is essentially issuing an invoice. At this point, it becomes a legal record so you can't make changes to it. Paddle automatically assigns an invoice number, creates [a related subscription](https://developer.paddle.com/api-reference/subscriptions/overview), and sends it to your customer.
     *
     *     When making changes to items on a transaction, send the complete list of items that you'd like to be on a transaction — including existing items. For each item, send an object containing `price_id` and `quantity`. Paddle responds with the full `price` object for each item. See: [Work with lists](https://developer.paddle.com/api-reference/about/lists)
     *
     *     If successful, your response includes a copy of the updated transaction entity.
     */
    patch: operations["update-transaction"];
    trace?: never;
  };
  "/transactions/{transaction_id}/revise": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the transaction entity to work with. */
        transaction_id: components["parameters"]["transaction_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Revise customer information on a billed or completed transaction
     * @description Revises customer information for a billed or completed transaction.
     *
     *     Revise a transaction to rectify incorrect customer, address, or business information on invoice documents generated by Paddle.
     *
     *     You can revise transaction details that don't impact the tax rates on a transaction. This includes:
     *
     *     * Customer name
     *     * Business name and tax or VAT number (`tax_identifier`)
     *     * Address details, apart from the country
     *
     *     You can't remove a valid tax or VAT number, only replace it with another valid one. If a valid tax or VAT number is added, Paddle automatically creates an adjustment to refund any tax where applicable.
     *
     *     Transactions can only be revised once.
     *
     *     If successful, your response includes a copy of the transaction entity. [Get a transaction](https://developer.paddle.com/api-reference/transactions/get-transaction) using the `include` parameter with the `customer`, `address`, and `business` values to see the revised customer information.
     *
     *     Only the customer information for this transaction is updated. The related customer, address, and business entities aren't updated.
     */
    post: operations["revise-transaction"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/adjustments": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List adjustments
     * @description Returns a paginated list of adjustments. Use the query parameters to page through results.
     */
    get: operations["list-adjustments"];
    put?: never;
    /**
     * Create an adjustment
     * @description Creates an adjustment for one or more transaction items.
     *
     *     You can create adjustments to refund or credit all or part of a transaction and its items:
     *
     *     * Refunds return an amount to a customer's original payment method. You can create refund adjustments for transactions that are `completed`.
     *     * Credits reduce the amount that a customer has to pay for a transaction. You can create credit adjustments for manually-collected transactions that are `billed` or `past_due`.
     *
     *     You can create adjustments to refund transactions that are `completed`, or to reduce the amount to due on manually-collected transactions that are `billed` or `past_due`.
     *     Most refunds for live accounts are created with the status of `pending_approval` until reviewed by Paddle, but [some are automatically approved](https://developer.paddle.com/build/transactions/create-transaction-adjustments#background-refunds). For sandbox accounts, Paddle automatically approves refunds every ten minutes.
     *
     *     Adjustments can apply to some or all items on a transaction. You'll need the Paddle ID of the transaction to create a refund or credit for, along with the Paddle ID of any transaction items (`details.line_items[].id`).
     *
     *     If successful, your response includes a copy of the new adjustment entity.
     */
    post: operations["create-adjustment"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/adjustments/{adjustment_id}/credit-note": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the adjustment entity to work with. */
        adjustment_id: components["parameters"]["adjustment_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a PDF credit note for an adjustment
     * @description Returns a link to a credit note PDF for an adjustment.
     *
     *     Credit note PDFs are created for refunds and credits as a record of an adjustment.
     *
     *     The link returned is not a permanent link. It expires after an hour.
     */
    get: operations["get-adjustment-credit-note"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers/{customer_id}/credit-balances": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    /**
     * List credit balances for a customer
     * @description Returns a list of credit balances for each currency for a customer. Each balance has three totals:
     *
     *     * `available`: total available to use.
     *     * `reserved`: total temporarily reserved for billed transactions.
     *     * `used`: total amount of credit used.
     *
     *     Credit is added to the `available` total initially. When used, it moves to the `used` total.
     *
     *     The `reserved` total is used when a credit balance is applied to a transaction that's marked as `billed`, like when working with an issued invoice. It's not available for other transactions at this point, but isn't considered `used` until the transaction is completed. If a `billed` transaction is `canceled`, any reserved credit moves back to `available`.
     *
     *     Credit balances are created automatically by Paddle when you take an action that results in Paddle creating a credit for a customer, like making prorated changes to a subscription. An empty `data` array is returned where a customer has no credit balances.
     *
     *     The response is not paginated.
     */
    get: operations["list-credit-balances"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List customers
     * @description Returns a paginated list of customers. Use the query parameters to page through results.
     *
     *     By default, Paddle returns customers that are `active`. Use the `status` query parameter to return customers that are archived.
     */
    get: operations["list-customers"];
    put?: never;
    /**
     * Create a customer
     * @description Creates a new customer.
     *
     *     If successful, your response includes a copy of the new customer entity.
     */
    post: operations["create-customer"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers/{customer_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a customer
     * @description Returns a customer using its ID.
     */
    get: operations["get-customer"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a customer
     * @description Updates a customer using its ID.
     *
     *     If successful, your response includes a copy of the updated customer entity.
     */
    patch: operations["update-customer"];
    trace?: never;
  };
  "/customers/{customer_id}/addresses": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    /**
     * List addresses for a customer
     * @description Returns a paginated list of addresses for a customer. Use the query parameters to page through results.
     *
     *     By default, Paddle returns addresses that are `active`. Use the `status` query parameter to return addresses that are archived.
     */
    get: operations["list-addresses"];
    put?: never;
    /**
     * Create an address for a customer
     * @description Creates a new address for a customer.
     *
     *     For tax calculation, fraud prevention, and compliance purposes, you must include a `postal_code` when creating addresses for some countries. For example, ZIP codes in the USA and postcodes in the UK. See: [Supported countries](https://developer.paddle.com/concepts/sell/supported-countries-locales)
     *
     *     If successful, your response includes a copy of the new address entity.
     */
    post: operations["create-address"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers/{customer_id}/addresses/{address_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the address entity to work with. */
        address_id: components["parameters"]["address_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get an address for a customer
     * @description Returns an address for a customer using its ID and related customer ID.
     */
    get: operations["get-address"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update an address for a customer
     * @description Updates an address for a customer using its ID and related customer ID.
     *
     *     If successful, your response includes a copy of the updated address entity.
     */
    patch: operations["update-address"];
    trace?: never;
  };
  "/customers/{customer_id}/auth-token": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Generate an authentication token for a customer
     * @description Generates an authentication token for a customer. You can pass a generated authentication token to Paddle.js when opening a checkout to let customers work with saved payment methods.
     *
     *     Authentication tokens are temporary and shouldn't be cached. They're valid until the `expires_at` date returned in the response.
     */
    post: operations["generate-customer-authentication-token"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers/{customer_id}/businesses": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    /**
     * List businesses for a customer
     * @description Returns a paginated list of businesses for a customer. Use the query parameters to page through results.
     *
     *     By default, Paddle returns businesses that are `active`. Use the `status` query parameter to return businesses that are archived.
     */
    get: operations["list-businesses"];
    put?: never;
    /**
     * Create a business for a customer
     * @description Creates a new business for a customer.
     *
     *     If successful, your response includes a copy of the new business entity.
     */
    post: operations["create-business"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers/{customer_id}/businesses/{business_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the business entity to work with. */
        business_id: components["parameters"]["business_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a business for a customer
     * @description Returns a business for a customer using its ID and related customer ID.
     */
    get: operations["get-business"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a business for a customer
     * @description Updates a business for a customer using its ID and related customer ID.
     *
     *     If successful, your response includes a copy of the updated business entity.
     */
    patch: operations["update-business"];
    trace?: never;
  };
  "/customers/{customer_id}/payment-methods": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    /**
     * List payment methods for a customer
     * @description Returns a paginated list of payment methods that a customer has saved.  Use the query parameters to page through results.
     *
     *     When customers sign up for a subscription using Paddle Checkout, Paddle saves the payment method for renewals, upgrades and downgrades, and other charges related to that subscription.
     *
     *     Customers can also choose to save payment methods when purchasing one-time items by checking a box when completing checkout. You can present customers with their saved payment methods when they make a purchase in the future.
     *
     *     Returns an empty list where customers have not saved any payment methods, or have deleted all previously saved payment methods.
     */
    get: operations["list-customer-payment-methods"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers/{customer_id}/payment-methods/{payment_method_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the payment method entity to work with. */
        payment_method_id: components["parameters"]["payment_method_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a payment method for a customer
     * @description Returns a payment method for a customer using its ID and related customer ID.
     */
    get: operations["get-customer-payment-method"];
    put?: never;
    post?: never;
    /**
     * Delete a payment method for a customer
     * @description Deletes a customer payment method using its ID.
     *
     *     When you delete a customer payment method, it's permanently removed from that customer.
     *
     *     There's no way to recover a deleted payment method.
     */
    delete: operations["delete-customer-payment-method"];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/customers/{customer_id}/portal-sessions": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a customer portal session
     * @description Creates a customer portal session for a customer.
     *
     *     The [customer portal](https://developer.paddle.com/concepts/customer-portal) is a secure, Paddle-hosted site that allows
     *     customers to manage their own subscriptions, payments, and account information without you having to build custom billing screens.
     *
     *     Customers can:
     *
     *     * View transaction history
     *     * Download invoices
     *     * Update payment methods
     *     * Manage their subscriptions including making changes or cancellations
     *     * Revise details on completed transactions
     *
     *     You can create a customer portal session to generate authenticated links for a customer
     *     so that they're automatically signed in to the portal. It's typically used when linking to
     *     the customer portal from your app where customers are already authenticated.
     *
     *     You can include an array of `subscription_ids` to generate authenticated portal links that let customers make
     *     changes to their subscriptions. You can use these links as part of subscription management workflows rather than
     *     building your own billing screens.
     *
     *     Customer portal sessions are temporary and shouldn't be cached.
     *
     *     The customer portal is fully hosted by Paddle. For security and the best customer experience, don't embed the customer
     *     portal in an iframe.
     */
    post: operations["create-customer-portal-session"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notification-settings": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List notification settings
     * @description Returns a paginated list of notification settings (notification destinations).
     */
    get: operations["list-notification-settings"];
    put?: never;
    /**
     * Create a notification setting
     * @description Creates a new notification setting (notification destination).
     *
     *     Pass an array of event type names to `subscribed_events` to say which events you'd like to subscribe to. Paddle responds with the full event type object for each event type.
     *
     *     If successful, your response includes a copy of the new notification setting entity. Use the returned `endpoint_secret_key` for webhook signature verification.
     */
    post: operations["create-notification-setting"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notification-settings/{notification_setting_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification setting entity (notification destination) to work with. */
        notification_setting_id: components["parameters"]["notification_setting_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a notification setting
     * @description Returns a notification setting (notification destination) using its ID.
     */
    get: operations["get-notification-setting"];
    put?: never;
    post?: never;
    /**
     * Delete a notification setting
     * @description Deletes a notification setting (notification destination) using its ID.
     *
     *     When you delete a notification setting, it's permanently removed from your account. Paddle stops sending events to your destination, and you'll lose access to all the logs for this notification setting.
     *
     *     There's no way to recover a deleted notification setting. Deactivate a notification setting using the update notification setting operation if you'll need access to the logs or want to reactivate later on.
     */
    delete: operations["delete-notification-setting"];
    options?: never;
    head?: never;
    /**
     * Update a notification setting
     * @description Updates a notification setting (notification destination) using its ID.
     *
     *     When updating subscribed events, send the complete list of event types that you'd like to subscribe to — including existing event types. If you omit event types, they're removed from the notification setting.
     *
     *     You only need to pass an event type name. Paddle responds with the full event type object for each event type.
     *
     *     If successful, your response includes a copy of the updated notification setting entity.
     */
    patch: operations["update-notification-setting"];
    trace?: never;
  };
  "/event-types": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List events types
     * @description Returns a list of event types.
     *
     *     The response is not paginated.
     */
    get: operations["list-event-types"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/events": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List events
     * @description Returns a paginated list of events that have occurred in the last 90 days. Use the query parameters to page through results.
     *
     *     Events older than 90 days aren't retained.
     *
     *     This is sometimes referred to as "the event stream."
     */
    get: operations["list-events"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List notifications
     * @description Returns a paginated list of notifications created in the last 90 days. Use the query parameters to page through results.
     *
     *     Notifications older than 90 days aren't retained.
     */
    get: operations["list-notifications"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/{notification_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification entity to work with. */
        notification_id: components["parameters"]["notification_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a notification
     * @description Returns a notification using its ID.
     *
     *     Notifications older than 90 days aren't retained. If you try to get a notification that's no longer retained, Paddle returns an error.
     */
    get: operations["get-notification"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/{notification_id}/logs": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification entity to work with. */
        notification_id: components["parameters"]["notification_id_path"];
      };
      cookie?: never;
    };
    /**
     * List logs for a notification
     * @description Returns a paginated list of notification logs for a notification. A log includes information about delivery attempts, including failures.
     *
     *     Notifications older than 90 days aren't retained. If you try to list logs for a notification that's no longer retained, Paddle returns an error.
     */
    get: operations["list-notification-logs"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/notifications/{notification_id}/replay": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification entity to work with. */
        notification_id: components["parameters"]["notification_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Replay a notification
     * @description Attempts to resend a `delivered` or `failed` notification using its ID.
     *
     *     Paddle creates a new notification entity for the replay, related to the same `event_id`. Your response includes the new `notification_id` of the created notification.
     *
     *     Notifications older than 90 days aren't retained. If you try to replay a notification that's no longer retained, Paddle returns an error.
     *
     *     Only notifications with the `origin` of `event` can be replayed. You can't replay a notification created for a replay.
     */
    post: operations["replay-notification"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/simulation-types": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List simulation types
     * @description Returns a list of simulation types (events and scenarios) that you can choose from when creating simulations.
     */
    get: operations["list-simulation-types"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/simulations": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List simulations
     * @description Returns a paginated list of simulations. Use the query parameters to [page through results](https://developer.paddle.com/api-reference/about/pagination).
     */
    get: operations["list-simulations"];
    put?: never;
    /**
     * Create a simulation
     * @description Creates a new simulation for a notification setting (notification destination).
     *
     *     For scenario simulations, you can optionally include a `config.entities` object in the request body with entity IDs to populate
     *     simulated webhook payloads with real data. The API key making the request needs read permissions:
     *
     *     * For the entities you provided, or the request fails.
     *     * For related entities which aren't nested in the entities you provided, or static examples will be used instead.
     *
     *     For example, when creating a subscription renewal scenario simulation with an API key that has a `subscription.read` permission but not a `transaction.read` permission,
     *     the request succeeds and the subscription data will be used in simulated payloads, but the related transaction data won't be used in payloads and falls back to a static example.
     *
     *     If you don't provide a `config.entities` object, simulated webhook payloads are populated with static examples.
     *
     *     If successful, your response includes a copy of the new simulation entity.
     */
    post: operations["create-simulation"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/simulations/{simulation_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a simulation
     * @description Returns a simulation using its ID.
     */
    get: operations["get-simulation"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a simulation
     * @description Updates a simulation using its ID.
     *
     *     For scenario simulations, you can optionally include a `config.entities` object in the request body with entity IDs to populate
     *     simulated webhook payloads with real data. The API key making the request needs read permissions:
     *
     *     * For the entities you provided, or the request fails.
     *     * For related entities which aren't nested in the entities you provided, or static examples will be used instead.
     *
     *     For example, when updating a subscription renewal scenario simulation with an API key that has a `subscription.read` permission but not a `transaction.read` permission,
     *     the request succeeds and the subscription data will be used in simulated payloads, but the related transaction data won't be used in payloads and falls back to a static example.
     *
     *     If you don't provide a `config.entities` object, simulated webhook payloads are populated with static examples.
     *
     *     If successful, your response includes a copy of the updated simulation entity.
     */
    patch: operations["update-simulation"];
    trace?: never;
  };
  "/simulations/{simulation_id}/runs": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
      };
      cookie?: never;
    };
    /**
     * List runs for a simulation
     * @description Returns a paginated list of simulation runs. Use the query parameters to [page through results](https://developer.paddle.com/api-reference/about/pagination).
     *
     *     Use the `include` parameter to [include related entities](https://developer.paddle.com/api-reference/about/include-entities) in the response.
     */
    get: operations["list-simulation-runs"];
    put?: never;
    /**
     * Create a run for a simulation
     * @description Creates a new simulation run for a simulation.
     *
     *     If successful, your response includes a copy of the new simulation run entity.
     */
    post: operations["create-simulation-run"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/simulations/{simulation_id}/runs/{simulation_run_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a run for a simulation
     * @description Returns a simulation run using its ID.
     *
     *     Use the `include` parameter to include related entities in the response.
     */
    get: operations["get-simulation-run"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/simulations/{simulation_id}/runs/{simulation_run_id}/events": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
      };
      cookie?: never;
    };
    /**
     * List events for a simulation run
     * @description Returns a paginated list of simulations. Use the query parameters to [page through results](https://developer.paddle.com/api-reference/about/pagination).
     */
    get: operations["list-simulations-events"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/simulations/{simulation_id}/runs/{simulation_run_id}/events/{simulation_event_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
        /** @description Paddle ID of the simulation event entity to work with. */
        simulation_event_id: components["parameters"]["simulation_event_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get an event for a simulation run
     * @description Returns a simulation event using its ID.
     *
     *     Use the `include` parameter to include related entities in the response.
     */
    get: operations["get-simulation-event"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/simulations/{simulation_id}/runs/{simulation_run_id}/events/{simulation_event_id}/replay": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
        /** @description Paddle ID of the simulation event entity to work with. */
        simulation_event_id: components["parameters"]["simulation_event_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Replay an event for a simulation run
     * @description Attempts to resend a simulation run log using its ID.
     *
     *     Paddle creates a new simulation run log entity for the replay, related to the same simulation run.
     *
     *     If successful, your response includes the new simulation run log entity.
     */
    post: operations["replay-simulation-run-event"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/ips": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Paddle IP addresses
     * @description Returns Paddle IP addresses. You can add these IP addresses to your allowlist.
     *
     *     IP addresses returned are for the environment that you're making the request in. For example, making the request to the production base URL returns all production IP addresses.
     */
    get: operations["get-ip-addresses"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/transactions/{transaction_id}/invoice": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the transaction entity to work with. */
        transaction_id: components["parameters"]["transaction_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a PDF invoice for a transaction
     * @description Returns a link to an invoice PDF for a transaction.
     *
     *     Invoice PDFs are available for both automatically and manually-collected transactions:
     *
     *     * The PDF for manually-collected transactions includes payment terms, purchase order number, and notes for your customer. It's a demand for payment from your customer. It's available for transactions that are `billed` or `completed`.
     *     * The PDF for automatically-collected transactions lets your customer know that payment was taken successfully. Customers may require this for for tax-reporting purposes. It's available for transactions that are `completed`.
     *
     *     Invoice PDFs aren't available for zero-value transactions.
     *
     *     The link returned is not a permanent link. It expires after an hour.
     */
    get: operations["get-transaction-invoice"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/discounts": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List discounts
     * @description Returns a paginated list of discounts. Use the query parameters to page through results.
     *
     *     By default, Paddle returns discounts that are `active`. Use the `status` query parameter to return discounts that are archived or expired.
     */
    get: operations["list-discounts"];
    put?: never;
    /**
     * Create a discount
     * @description Creates a new discount.
     *
     *     If successful, your response includes a copy of the new discount entity.
     */
    post: operations["create-discount"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/discounts/{discount_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the discount entity to work with. */
        discount_id: components["parameters"]["discount_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a discount
     * @description Returns a discount using its ID.
     */
    get: operations["get-discount"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a discount
     * @description Updates a discount using its ID.
     *
     *     If successful, your response includes a copy of the updated discount entity.
     *
     *     To update a checkout recovery discount, configure your checkout recovery settings in the dashboard.
     */
    patch: operations["update-discount"];
    trace?: never;
  };
  "/subscriptions/{subscription_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a subscription
     * @description Returns a subscription using its ID.
     *
     *     Use the `include` parameter to include transaction information in the response.
     */
    get: operations["get-subscription"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a subscription
     * @description Updates a subscription using its ID.
     *
     *     When making changes to items or the next billing date for a subscription, you must include the `proration_billing_mode` field to tell Paddle how to bill for those changes.
     *
     *     Send the complete list of items that you'd like to be on a subscription — including existing items. If you omit items, they're removed from the subscription.
     *
     *     For each item, send `price_id` and `quantity`. Paddle responds with the full price object for each price. If you're updating an existing item, you can omit the `quantity` if you don't want to update it.
     *
     *     If successful, your response includes a copy of the updated subscription entity. When an update results in an immediate charge, responses may take longer than usual while a payment attempt is processed.
     */
    patch: operations["update-subscription"];
    trace?: never;
  };
  "/subscriptions": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List subscriptions
     * @description Returns a paginated list of subscriptions. Use the query parameters to page through results.
     */
    get: operations["list-subscriptions"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subscriptions/{subscription_id}/cancel": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel a subscription
     * @description Cancels a subscription using its ID.
     *
     *     By default, active subscriptions are canceled at the end of the billing period. When you send a request to cancel, Paddle creates a `scheduled_change` against the subscription entity to say that it should cancel at the end of the current billing period. Its `status` remains `active` until after the effective date of the scheduled change, at which point it changes to `canceled`.
     *
     *     You can cancel a subscription right away by including `effective_from` in your request, setting the value to `immediately`. If successful, your response includes a copy of the updated subscription entity with the `status` of `canceled`. Canceling immediately is the default behavior for paused subscriptions.
     *
     *     You can't reinstate a canceled subscription.
     */
    post: operations["cancel-subscription"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subscriptions/{subscription_id}/pause": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pause a subscription
     * @description Pauses a subscription using its ID.
     *
     *     By default, subscriptions are paused at the end of the billing period. When you send a request to pause, Paddle creates a `scheduled_change` against the subscription entity to say that it should pause at the end of the current billing period. Its `status` remains `active` until after the effective date of the scheduled change, at which point it changes to `paused`.
     *
     *     You can pause a subscription right away by including `effective_from` in your request, setting the value to `immediately`. If successful, your response includes a copy of the updated subscription entity with the `status` of `paused`.
     *
     *     To set a resume date, include the `resume_at` field in your request. The subscription remains paused until the resume date, or until you send a resume request. Omit to create an open-ended pause. The subscription remains paused indefinitely, until you send a resume request.
     */
    post: operations["pause-subscription"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subscriptions/{subscription_id}/resume": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Resume a paused subscription
     * @description Resumes a paused subscription using its ID. Only `paused` subscriptions can be resumed. If an `active` subscription has a scheduled change to pause in the future, use this operation to set or change the resume date.
     *
     *     You can't resume a `canceled` subscription.
     *
     *     On resume, Paddle bills for a subscription immediately by default. Subscription billing dates are recalculated based on the resume date. Use the `on_resume` field to change this behavior.
     *
     *     If successful, Paddle returns a copy of the updated subscription entity:
     *
     *     * When resuming a `paused` subscription immediately, the subscription status is `active`, and billing dates are updated to reflect the resume date.
     *     * When scheduling a `paused` subscription to resume on a date in the future, the subscription status is `paused`, and `scheduled_change.resume_at` is updated to reflect the scheduled resume date.
     *     * When changing the resume date for an `active` subscription that's scheduled to pause, the subscription status is `active` and `scheduled_change.resume_at` is updated to reflect the scheduled resume date.
     *
     *     This operation may result in an immediate charge, so responses may take longer than usual while a payment attempt is processed.
     */
    post: operations["resume-subscription"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subscriptions/{subscription_id}/activate": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Activate a trialing subscription
     * @description Activates a trialing subscription using its ID. Only automatically-collected subscriptions where the status is `trialing` can be activated.
     *
     *     On activation, Paddle bills for a subscription immediately. Subscription billing dates are recalculated based on the activation date (the time the activation request is made).
     *
     *     If successful, Paddle returns a copy of the updated subscription entity. The subscription status is `active`, and billing dates are updated to reflect the activation date.
     *
     *     This operation results in an immediate charge, so responses may take longer than usual while a payment attempt is processed.
     */
    post: operations["activate-subscription"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subscriptions/{subscription_id}/update-payment-method-transaction": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a transaction to update payment method
     * @description Returns a transaction that you can pass to a checkout to let customers update their payment details. Only for subscriptions where `collection_mode` is `automatic`.
     *
     *     The transaction returned depends on the status of the related subscription:
     *
     *     * Where a subscription is `past_due`, it returns the most recent `past_due` transaction.
     *     * Where a subscription is `active`, it creates a new zero amount transaction for the items on a subscription.
     *
     *     You can use the returned `checkout.url`, or pass the returned transaction ID to Paddle.js to open a checkout to present customers with a way of updating their payment details.
     *
     *     The `customer`, `address`, `business`, `discount`, `adjustments` and `adjustments_totals` properties are only returned in the response if the API key has read permissions for those related entities.
     */
    get: operations["get-subscription-update-payment-method-transaction"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subscriptions/{subscription_id}/preview": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Preview an update to a subscription
     * @description Previews an update for a subscription without applying those changes. Typically used for previewing proration before making changes to a subscription.
     *
     *     If successful, your response includes `immediate_transaction`, `next_transaction`, and `recurring_transaction_details` so you can see expected transactions for the changes.
     *
     *     The `update_summary` object contains details of prorated credits and charges created, along with the overall result of the update.
     */
    patch: operations["preview-subscription-update"];
    trace?: never;
  };
  "/subscriptions/{subscription_id}/charge": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a one-time charge for a subscription
     * @description Creates a new one-time charge for a subscription. Use to bill non-recurring items to a subscription. Non-recurring items are price entities where the `billing_cycle` is `null`.
     *
     *     If successful, Paddle responds with the updated subscription entity. However, one-time charges aren't held against the subscription entity, so the charges billed aren't returned in the response.
     *
     *     Once created, to get details of a one-time charge:
     *
     *     * When created with `effective_from` as `next_billing_period`, get the subscription the charge was billed to and use the `include` query parameter with the `next_transaction` value.
     *     * When created with `effective_from` as `immediately`, list transactions and use the `subscription_id` query parameter with the subscription ID of the subscription the charge was billed to.
     *
     *     When an update results in an immediate charge, responses may take longer than usual while a payment attempt is processed.
     */
    post: operations["create-subscription-charge"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/subscriptions/{subscription_id}/charge/preview": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Preview a one-time charge for a subscription
     * @description Previews creating a one-time charge for a subscription without billing that charge. Typically used for previewing calculations before making changes to a subscription.
     *
     *     One-time charges are non-recurring items. These are price entities where the `billing_cycle` is `null`.
     *
     *     If successful, your response includes `immediate_transaction`, `next_transaction`, and `recurring_transaction_details` so you can see expected transactions for the changes.
     */
    post: operations["preview-subscription-charge"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/reports": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List reports
     * @description Returns a paginated list of reports. Use the query parameters to page through results.
     *
     *     By default, Paddle returns reports that are `pending` or `ready`. Use the `status` query parameter to return reports that are `failed`, `expired`, or `deleted`.
     */
    get: operations["list-reports"];
    put?: never;
    /**
     * Create a report
     * @description Creates a new report.
     *
     *     Reports are created as `pending` initially while Paddle generates your report. They move to `ready` when they're ready to download.
     *
     *     You can download a report when it's ready using the [get a CSV file for a report operation](https://developer.paddle.com/api-reference/reports/get-report-csv).
     *
     *     If successful, your response includes a copy of the new report entity.
     */
    post: operations["create-report"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/reports/{report_id}/download-url": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the report entity. */
        report_id: components["parameters"]["report_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a CSV file for a report
     * @description Returns a link to a CSV file for a report.
     *
     *     Only returned for reports that are `ready`. This means Paddle has completed processing the report and it's ready to download.
     *
     *     The link returned is not a permanent link. It expires after 3 minutes.
     */
    get: operations["get-report-csv"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/reports/{report_id}": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the report entity. */
        report_id: components["parameters"]["report_id_path"];
      };
      cookie?: never;
    };
    /**
     * Get a report
     * @description Returns a report using its ID.
     */
    get: operations["get-report"];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export interface webhooks {
  "address.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * address.created
     * @description Occurs when an address is created.
     */
    post: operations["address-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "address.imported": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * address.imported
     * @description Occurs when an address is imported.
     */
    post: operations["address-imported"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "address.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * address.updated
     * @description Occurs when an address is updated.
     */
    post: operations["address-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "adjustment.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * adjustment.created
     * @description Occurs when an adjustment is created.
     */
    post: operations["adjustment-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "adjustment.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * adjustment.updated
     * @description Occurs when an adjustment is updated.
     *
     *     This only occurs for `refund` adjustments, which must be approved by Paddle and are created as `pending_approval`
     *     initially. On review, they move to `approved` or `rejected` and `adjustment.updated` occurs.
     */
    post: operations["adjustment-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "api_key.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * api_key.created
     * @description Occurs when an API key is created.
     */
    post: operations["api-key-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "api_key.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * api_key.updated
     * @description Occurs when an API key is updated.
     */
    post: operations["api-key-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "api_key.expired": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * api_key.expired
     * @description Occurs when an API key has expired.
     */
    post: operations["api-key-expired"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "api_key.expiring": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * api_key.expiring
     * @description Occurs when an API key expires in 7 days.
     */
    post: operations["api-key-expiring"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "api_key.revoked": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * api_key.revoked
     * @description Occurs when an API key has been revoked.
     */
    post: operations["api-key-revoked"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "business.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * business.created
     * @description Occurs when an business is created.
     */
    post: operations["business-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "business.imported": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * business.imported
     * @description Occurs when an business is imported.
     */
    post: operations["business-imported"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "business.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * business.updated
     * @description Occurs when an business is updated.
     */
    post: operations["business-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "customer.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * customer.created
     * @description Occurs when an customer is created.
     */
    post: operations["customer-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "customer.imported": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * customer.imported
     * @description Occurs when an customer is imported.
     */
    post: operations["customer-imported"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "customer.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * customer.updated
     * @description Occurs when an customer is updated.
     */
    post: operations["customer-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "discount.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * discount.created
     * @description Occurs when a discount is created.
     *
     *     Payload includes the complete discount entity, except `times_used`. This field changes frequently, so isn't included in payloads. [Get a discount using the API](https://developer.paddle.com/api-reference/discounts/get-discount) to see the latest value.
     */
    post: operations["discount-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "discount.imported": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * discount.imported
     * @description Occurs when a discount is imported.
     *
     *     Payload includes the complete discount entity, except `times_used`. This field changes frequently, so isn't included in payloads. [Get a discount using the API](https://developer.paddle.com/api-reference/discounts/get-discount) to see the latest value.
     */
    post: operations["discount-imported"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "discount.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * discount.updated
     * @description Occurs when a discount is updated.
     *
     *     Payload includes the complete discount entity, except `times_used`. This field changes frequently, so isn't included in payloads. [Get a discount using the API](https://developer.paddle.com/api-reference/discounts/get-discount) to see the latest value.
     */
    post: operations["discount-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "payment_method.saved": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * payment_method.saved
     * @description Occurs when a payment method is saved.
     */
    post: operations["payment-method-saved"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "payment_method.deleted": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * payment_method.deleted
     * @description Occurs when a payment method is deleted.
     */
    post: operations["payment-method-deleted"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "payout.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * payout.created
     * @description Occurs when a payout is initiated by Paddle.
     */
    post: operations["payout-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "payout.paid": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * payout.paid
     * @description Occurs when a payout is paid. This is usually the working day before the funds credit your account.
     */
    post: operations["payout-paid"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "price.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * price.created
     * @description Occurs when a price is created.
     *
     *     `created_at` and `updated_at` may be `null` in events that occurred before this field was added to price entities.
     */
    post: operations["price-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "price.imported": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * price.imported
     * @description Occurs when a price is imported.
     *
     *     `created_at` and `updated_at` may be `null` in events that occurred before this field was added to price entities.
     */
    post: operations["price-imported"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "price.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * price.updated
     * @description Occurs when a price is updated.
     *
     *     `created_at` and `updated_at` may be `null` in events that occurred before this field was added to price entities.
     */
    post: operations["price-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "product.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * product.created
     * @description Occurs when a product is created.
     *
     *     `updated_at` may be `null` in events that occurred before this field was added to product entities.
     */
    post: operations["product-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "product.imported": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * product.imported
     * @description Occurs when a product is imported.
     *
     *     `updated_at` may be `null` in events that occurred before this field was added to product entities.
     */
    post: operations["product-imported"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "product.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * product.updated
     * @description Occurs when a product is updated.
     *
     *     `updated_at` may be `null` in events that occurred before this field was added to product entities.
     */
    post: operations["product-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "report.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * report.created
     * @description Occurs when an report is created.
     */
    post: operations["report-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "report.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * report.updated
     * @description Occurs when an report is updated.
     */
    post: operations["report-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.activated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.activated
     * @description Occurs when a subscription becomes active. Its `status` field changes to `active`.
     *
     *     This means any trial period has elapsed and Paddle has successfully billed the customer.
     *
     *     Payload includes the complete subscription entity, except `management_urls` .Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-activated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.canceled": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.canceled
     * @description Occurs when a subscription is canceled. Its `status` field changes to `canceled`.
     *
     *     If you choose to cancel a subscription immediately, the subscription status changes to `canceled` and `subscription.canceled` occurs.
     *
     *     If you choose to cancel a subscription on the next billing period, Paddle creates a scheduled change to say the subscription should be canceled on the next billing date. [`subscription.updated`](https://developer.paddle.com/webhooks/subscriptions/subscription-updated) occurs at this point. On the next billing date, the subscription status changes to `canceled` and `subscription.canceled` occurs.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-canceled"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.created
     * @description Occurs when a subscription is created. Paddle automatically creates subscriptions for recurring items when automatically-collected transactions are `completed`, or when manually-collected transactions are `billed`.
     *
     *     [`subscription.trialing`](/webhooks/subscriptions/subscription-trialing) or [`subscription.activated`](/webhooks/subscriptions/subscription-activated) typically follow.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     *
     *     It also includes a `transaction_id` field, which contains the Paddle ID of the completed or billed transaction that caused Paddle to create this subscription. You can use this match the created subscription with related transaction events [as part of provisioning](/build/subscriptions/provision-access-webhooks). Other subscription events don't include this field, and it is not returned by the API when working with subscription entities.
     */
    post: operations["subscription-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.past_due": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.past_due
     * @description Occurs when a subscription has an unpaid transaction. Its `status` changes to `past_due`.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-past_due"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.imported": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.imported
     * @description Occurs when a subscription is imported.
     *
     *     [`subscription.trialing`](https://developer.paddle.com/webhooks/subscriptions/subscription-trialing) or [`subscription.activated`](https://developer.paddle.com/webhooks/subscriptions/subscription-activated) typically follow.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-imported"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.paused": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.paused
     * @description Occurs when a subscription is paused. Its `status` field changes to `paused`.
     *
     *     If you choose to pause a subscription immediately, the subscription status changes to `paused` and `subscription.paused` occurs.
     *
     *     If you choose to pause a subscription on the next billing period, Paddle creates a scheduled change to say the subscription should be paused on the next billing date. [`subscription.updated`](https://developer.paddle.com/webhooks/subscriptions/subscription-updated) occurs at this point. On the next billing date, the subscription status changes to `paused` and `subscription.paused` occurs.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-paused"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.resumed": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.resumed
     * @description Occurs when a subscription is resumed after being paused. Its status field changes to `active`.
     *
     *     When resumed, Paddle bills for the subscription immediately. [`transaction.created`](https://developer.paddle.com/webhooks/transactions/transaction-created) and other transaction events occur, depending on the collection mode.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-resumed"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.trialing": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.trialing
     * @description Occurs when a subscription enters trial period.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-trialing"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "subscription.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * subscription.updated
     * @description Occurs when a subscription is updated.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](https://developer.paddle.com/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    post: operations["subscription-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.billed": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.billed
     * @description Occurs when a transaction is billed. Its `status` field changes to `billed` and `billed_at` is populated.
     *
     *     Marking a transaction as billed is typically used when working with manually-collected transactions to issue an
     *     invoice. It's not typically part of checkout workflows, where collection mode is automatic.
     *
     *     Transactions are marked as billed when:
     *
     *     * You update its status to `billed` using the API.
     *     * You send an invoice (a manually-collected transaction) using the Paddle dashboard.
     *
     *     Billed transactions get an invoice number. They're considered legal records, so they can't be deleted or changed.
     *
     *     [`transaction.updated`](https://developer.paddle.com/webhooks/transactions/transaction-updated) events occur immediately after to add:
     *
     *     * `invoice_number`, and `invoice_id` if not already present.
     *     * If manually-collected, the newly created `subscription_id` for any recurring items.
     */
    post: operations["transaction-billed"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.canceled": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.canceled
     * @description Occurs when a transaction is canceled. Its `status` field changes to `canceled`.
     *
     *     Marking a transaction as canceled is typically used when working with manually-collected transactions to say that an
     *     invoice was created in error. It's not typically part of checkout workflows, where collection mode is automatic.
     *
     *     Transactions are marked as canceled when:
     *
     *     * You update its status to `canceled` using the API.
     *     * You cancel an invoice (a manually-collected transaction) using the Paddle dashboard.
     */
    post: operations["transaction-canceled"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.completed": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.completed
     * @description Occurs when a transaction is completed. Its status field changes to `completed`.
     *
     *     Transactions move to completed after they're `paid`. After a transaction is paid, Paddle starts completed transaction processing. This involves:
     *
     *     * Logging details of the successful payment against `transaction.payments[]`.
     *     * Adding information about fees, earnings, and totals for payouts to the transaction entity.
     *     * For automatically-collected transactions, creating a subscription for any recurring items and adding the related `subscription_id` to the transaction entity.
     *     * For automatically-collected transactions, adding an `invoice_number` and `invoice_id` to the transaction entity.
     *
     *     [`transaction.updated`](https://developer.paddle.com/webhooks/transactions/transaction-updated) occurs as Paddle updates a paid transaction.
     *
     *     When all processing is completed, a transaction is marked as completed and `transaction.completed` occurs.
     */
    post: operations["transaction-completed"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.created": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.created
     * @description Occurs when a transaction is created. Paddle creates a transaction when:
     *
     *     * Customers open checkout.
     *     * You create an invoice in the Paddle dashboard.
     *
     *     You may also create a transaction using the API:
     *
     *     * Create a manually-collected transaction to create and send an invoice.
     *     * Create an automatically-collected transaction and pass to a checkout to collect for payment.
     *
     *     Where a transaction has `items`, `customer_id`, and `address_id`,
     *     [`transaction.ready`](https://developer.paddle.com/webhooks/transactions/transaction-ready) occurs immediately after.
     */
    post: operations["transaction-created"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.paid": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.paid
     * @description Occurs when a transaction is paid. Its status field changes to `paid`.
     *
     *     Transactions are paid when payment has been captured successfully, but Paddle hasn't yet fully processed the transaction internally.
     *
     *     For example:
     *
     *     * Payout totals may not be present.
     *     * Automatically-collected transactions for recurring items might not yet have a `subscription_id`.
     *     * Automatically-collected transactions might not yet have an `invoice_number`.
     *
     *     Transactions move to `completed` and [`transaction.completed`](https://developer.paddle.com/webhooks/transactions/transaction-completed) occurs when they're fully processed.
     */
    post: operations["transaction-paid"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.past_due": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.past_due
     * @description Occurs when a transaction becomes past due. Its `status` field changes to `past_due`.
     *
     *     * Automatically-collected transactions for subscription renewals become past due when a payment attempt fails.
     *     * Manually-collected transactions become past due when no payment has been received and the payment terms have elapsed.
     *
     *     The status against the related subscription for a transaction also changes to `past_due`, and
     *     [`subscription.past_due`](https://developer.paddle.com/webhooks/subscriptions/subscription-past-due) occurs.
     */
    post: operations["transaction-past_due"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.payment_failed": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.payment_failed
     * @description Occurs when a payment fails for a transaction. The `payments` array is updated with details of the payment attempt.
     *
     *     Typically happens for automatically-collected transactions, but may occur for manually-collected transactions
     *     (invoices) where a customer pays using Paddle Checkout and their payment is declined.
     *
     *     If related to a subscription renewal:
     *
     *     * The transaction status changes to `past_due` and [`transaction.past_due`](https://developer.paddle.com/webhooks/transactions/transaction-past-due)
     *     occurs.
     *     * The related subscription status changes to `past_due` and
     *     [`subscription.past_due`](https://developer.paddle.com/webhooks/subscriptions/subscription-past-due) occurs.
     *
     *     Manually-collected transactions are marked as `past_due` when the payment terms have elapsed.
     */
    post: operations["transaction-payment_failed"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.ready": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.ready
     * @description Occurs when a transaction is ready to be billed. Its `status` field changes to `ready`.
     *
     *     Transactions are ready when they have all the required fields against them to be transitioned to `billed` or
     *     `completed`. This includes `items`, `customer_id`, and `address_id`. Paddle automatically marks transactions as
     *     `ready` when these fields are present.
     *
     *     When working with manually-collected transactions (invoices), [`transaction.updated`](https://developer.paddle.com/webhooks/transactions/transaction-updated)
     *     may occur immediately after to add `invoice_id` and `adjusted_totals`.
     */
    post: operations["transaction-ready"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.updated": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.updated
     * @description Occurs when a transaction is updated.
     *
     *     Specific events occur for status changes. `transaction.updated` may also occur after a status change events to add
     *     additional fields to the transaction after Paddle has completed internal processing for a transaction.
     *
     *     For example, [`transaction.billed`](https://developer.paddle.com/webhooks/transactions/transaction-billed) occurs when a transaction status
     *     changes to `billed`. `transaction.updated` occurs immediately after to add an `invoice_number`.
     */
    post: operations["transaction-updated"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "transaction.revised": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * transaction.revised
     * @description Occurs when a transaction is revised.
     */
    post: operations["transaction-revised"];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export interface components {
  schemas: {
    /**
     * Address
     * @description Represents an address entity.
     */
    address: {
      readonly id: components["schemas"]["address_id"];
      /** @description Paddle ID for the customer related to this address, prefixed with `cus_`. */
      readonly customer_id: components["schemas"]["customer_id"];
      description: components["schemas"]["address_description"];
      first_line: components["schemas"]["address_first_line"];
      second_line: components["schemas"]["address_second_line"];
      city: components["schemas"]["address_city"];
      postal_code: components["schemas"]["address_postal_code"];
      region: components["schemas"]["address_region"];
      /** @description Supported two-letter ISO 3166-1 alpha-2 country code for this address. */
      country_code: components["schemas"]["country_code"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @default active */
      status: components["schemas"]["status"];
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
    };
    /**
     * AddressCreate
     * @description Represents an address entity when creating addresses.
     */
    "address-create": {
      readonly id?: components["schemas"]["address_id"];
      /** @description Memorable description for this address. */
      description?: string | null;
      /** @description First line of this address. */
      first_line?: string | null;
      /** @description Second line of this address. */
      second_line?: string | null;
      /** @description City of this address. */
      city?: string | null;
      /** @description ZIP or postal code of this address. Required for some countries. */
      postal_code?: string | null;
      /** @description State, county, or region of this address. */
      region?: string | null;
      /** @description Supported two-letter ISO 3166-1 alpha-2 country code for this address. */
      country_code: components["schemas"]["country_code"];
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta?: components["schemas"]["import_meta"] | null;
    };
    /**
     * AddressPreview
     * @description Represents an address entity when previewing addresses.
     */
    "address-preview": {
      /** @description ZIP or postal code of this address. Include for more accurate tax calculations. */
      postal_code?: string | null;
      /** @description Supported two-letter ISO 3166-1 alpha-2 country code for this address. */
      country_code: components["schemas"]["country_code"];
    };
    /**
     * AddressUpdate
     * @description Represents an address entity when updating addresses.
     */
    "address-update": {
      /** @description Memorable description for this address. */
      description: string | null;
      /** @description First line of this address. */
      first_line: string | null;
      /** @description Second line of this address. */
      second_line: string | null;
      /** @description City of this address. */
      city: string | null;
      /** @description ZIP or postal code of this address. Required for some countries. */
      postal_code: string | null;
      /** @description State, county, or region of this address. */
      region: string | null;
      /** @description Supported two-letter ISO 3166-1 alpha-2 country code for this address. */
      country_code: components["schemas"]["country_code"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      status: components["schemas"]["status"];
    };
    /**
     * address.created
     * @description Occurs when an address is created.
     */
    "address.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Address Notification */
      data?: {
        readonly id: components["schemas"]["address_id"];
        /** @description Paddle ID for the customer related to this address, prefixed with `cus_`. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Memorable description for this address. */
        description: string | null;
        /** @description First line of this address. */
        first_line: string | null;
        /** @description Second line of this address. */
        second_line: string | null;
        /** @description City of this address. */
        city: string | null;
        /** @description ZIP or postal code of this address. Required for some countries. */
        postal_code: string | null;
        /** @description State, county, or region of this address. */
        region: string | null;
        /** @description Supported two-letter ISO 3166-1 alpha-2 country code for this address. */
        country_code: components["schemas"]["country_code"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @default active */
        status: components["schemas"]["status"];
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * address.imported
     * @description Occurs when an address is imported.
     */
    "address.imported": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Address Notification */
      data?: {
        readonly id: components["schemas"]["address_id"];
        /** @description Paddle ID for the customer related to this address, prefixed with `cus_`. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Memorable description for this address. */
        description: string | null;
        /** @description First line of this address. */
        first_line: string | null;
        /** @description Second line of this address. */
        second_line: string | null;
        /** @description City of this address. */
        city: string | null;
        /** @description ZIP or postal code of this address. Required for some countries. */
        postal_code: string | null;
        /** @description State, county, or region of this address. */
        region: string | null;
        /** @description Supported two-letter ISO 3166-1 alpha-2 country code for this address. */
        country_code: components["schemas"]["country_code"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @default active */
        status: components["schemas"]["status"];
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * address.updated
     * @description Occurs when an address is updated.
     */
    "address.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Address Notification */
      data?: {
        readonly id: components["schemas"]["address_id"];
        /** @description Paddle ID for the customer related to this address, prefixed with `cus_`. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Memorable description for this address. */
        description: string | null;
        /** @description First line of this address. */
        first_line: string | null;
        /** @description Second line of this address. */
        second_line: string | null;
        /** @description City of this address. */
        city: string | null;
        /** @description ZIP or postal code of this address. Required for some countries. */
        postal_code: string | null;
        /** @description State, county, or region of this address. */
        region: string | null;
        /** @description Supported two-letter ISO 3166-1 alpha-2 country code for this address. */
        country_code: components["schemas"]["country_code"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @default active */
        status: components["schemas"]["status"];
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * City
     * @description City of this address.
     */
    address_city: string | null;
    /**
     * Description
     * @description Memorable description for this address.
     */
    address_description: string | null;
    /**
     * First line
     * @description First line of this address.
     */
    address_first_line: string | null;
    /**
     * Address ID
     * @description Unique Paddle ID for this address entity, prefixed with `add_`.
     */
    address_id: string;
    /**
     * Postal Code
     * @description ZIP or postal code of this address. Required for some countries.
     */
    address_postal_code: string | null;
    /**
     * Region
     * @description State, county, or region of this address.
     */
    address_region: string | null;
    /**
     * Second line
     * @description Second line of this address.
     */
    address_second_line: string | null;
    /**
     * Adjustment
     * @description Represents an adjustment entity.
     */
    adjustment: {
      readonly id: components["schemas"]["adjustment_id"];
      action: components["schemas"]["adjustment_action"];
      type: components["schemas"]["adjustment_type"];
      /** @description Paddle ID of the transaction that this adjustment is for, prefixed with `txn_`. */
      transaction_id: components["schemas"]["transaction_id"];
      /** @description Paddle ID for the subscription related to this adjustment, prefixed with `sub_`.
       *     Set automatically by Paddle based on the `subscription_id` of the related transaction. */
      readonly subscription_id: components["schemas"]["subscription_id"] | null;
      /** @description Paddle ID for the customer related to this adjustment, prefixed with `ctm_`.
       *     Set automatically by Paddle based on the `customer_id` of the related transaction. */
      readonly customer_id: components["schemas"]["customer_id"];
      /** @description Why this adjustment was created. Appears in the Paddle dashboard. Retained for record-keeping purposes. */
      reason: string;
      /** @description Whether this adjustment was applied to the related customer's credit balance. Only returned for `credit` adjustments. */
      readonly credit_applied_to_balance: boolean | null;
      /** @description Three-letter ISO 4217 currency code for this adjustment. Set automatically by Paddle based on the `currency_code` of the related transaction. */
      readonly currency_code: components["schemas"]["currency_code"];
      readonly status: components["schemas"]["status-adjustment"];
      /** @description List of items on this adjustment. Required if `type` is not populated or set to `partial`. */
      items: ({
        /** @description Unique Paddle ID for this adjustment item, prefixed with `adjitm_`. */
        readonly id?: components["schemas"]["adjustment_item_id"];
      } & components["schemas"]["adjustment_item"])[];
      readonly totals: components["schemas"]["adjustment_totals"];
      /** @description Breakdown of how this adjustment affects your payout balance. */
      readonly payout_totals: components["schemas"]["adjustment_payout_totals"] | null;
      readonly tax_rates_used: components["schemas"]["adjustment-tax-rates-used"];
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
    };
    /**
     * AdjustmentCreate
     * @description Represents an adjustment entity when creating adjustments.
     */
    "adjustment-create": {
      readonly id?: components["schemas"]["adjustment_id"];
      action: components["schemas"]["adjustment_action"];
      type?: components["schemas"]["adjustment_type"];
      tax_mode?: components["schemas"]["adjustment_tax_mode"];
      /** @description Paddle ID of the transaction that this adjustment is for, prefixed with `txn_`.
       *
       *     Automatically-collected transactions must be `completed`; manually-collected transactions must have a status of `billed` or `past_due`
       *
       *     You can't create an adjustment for a transaction that has a refund that's pending approval. */
      transaction_id: components["schemas"]["transaction_id"];
      /** @description Paddle ID for the subscription related to this adjustment, prefixed with `sub_`.
       *     Set automatically by Paddle based on the `subscription_id` of the related transaction. */
      readonly subscription_id?: components["schemas"]["subscription_id"] | null;
      /** @description Paddle ID for the customer related to this adjustment, prefixed with `ctm_`.
       *     Set automatically by Paddle based on the `customer_id` of the related transaction. */
      readonly customer_id?: components["schemas"]["customer_id"];
      /** @description Why this adjustment was created. Appears in the Paddle dashboard. Retained for recordkeeping purposes. */
      reason: string;
      /** @description Whether this adjustment was applied to the related customer's credit balance. Only returned for `credit` adjustments. */
      readonly credit_applied_to_balance?: boolean | null;
      /** @description Three-letter ISO 4217 currency code for this adjustment. Set automatically by Paddle based on the `currency_code` of the related transaction. */
      readonly currency_code?: components["schemas"]["currency_code"];
      readonly status?: components["schemas"]["status-adjustment"];
      /** @description List of transaction items to adjust. Required if `type` is not populated or set to `partial`. */
      items?:
        | ({
            /** @description Unique Paddle ID for this adjustment item, prefixed with `adjitm_`. */
            readonly id?: components["schemas"]["adjustment_item_id"];
          } & components["schemas"]["adjustment_item"])[]
        | null;
      readonly totals?: components["schemas"]["adjustment_totals"];
      /** @description Breakdown of how this adjustment affects your payout balance. */
      readonly payout_totals?: components["schemas"]["adjustment_payout_totals"] | null;
      readonly created_at?: components["schemas"]["created_at"];
      readonly updated_at?: components["schemas"]["updated_at"];
    };
    /**
     * AdjustmentPreview
     * @description Represents an adjustment entity when previewing adjustments.
     */
    "adjustment-preview": {
      /** @description Paddle ID for this transaction entity that this adjustment relates to, prefixed with `txn_`. */
      transaction_id: components["schemas"]["transaction_id"];
      tax_mode?: components["schemas"]["adjustment_tax_mode"];
      /** @description List of transaction items that this adjustment is for. */
      items: components["schemas"]["adjustment_item"][];
      /** @description Calculated totals for this adjustment. */
      totals?: components["schemas"]["adjustment_totals"];
    };
    /**
     * AdjustmentTaxRateUsed
     * @description List of tax rates applied for this adjustment.
     */
    "adjustment-tax-rates-used": {
      /** @description Rate used to calculate tax for this adjustment. */
      readonly tax_rate: string;
      /**
       * AdjustmentTaxRateUsedTotals
       * @description Calculated totals for the tax applied to this adjustment.
       */
      readonly totals: {
        /** @description Total before tax. For tax adjustments, the value is 0. */
        readonly subtotal: string;
        /** @description Total tax on the subtotal. */
        readonly tax: string;
        /** @description Total after tax. */
        readonly total: string;
      };
    }[];
    /**
     * adjustment.created
     * @description Occurs when an adjustment is created.
     */
    "adjustment.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Adjustment Notification */
      data?: {
        readonly id: components["schemas"]["adjustment_id"];
        action: components["schemas"]["adjustment_action"];
        type: components["schemas"]["adjustment_type"] | null;
        /** @description Paddle ID of the transaction that this adjustment is for, prefixed with `txn_`. */
        transaction_id: components["schemas"]["transaction_id"];
        /** @description Paddle ID for the subscription related to this adjustment, prefixed with `sub_`.
         *     Set automatically by Paddle based on the `subscription_id` of the related transaction. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /** @description Paddle ID for the customer related to this adjustment, prefixed with `ctm_`.
         *     Set automatically by Paddle based on the `customer_id` of the related transaction. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Why this adjustment was created. Appears in the Paddle dashboard. Retained for recordkeeping purposes. */
        reason: string;
        /** @description Whether this adjustment was applied to the related customer's credit balance. `null` unless adjustment `action` is not `credit`. */
        readonly credit_applied_to_balance: boolean | null;
        /** @description Three-letter ISO 4217 currency code for this adjustment. Set automatically by Paddle based on the `currency_code` of the related transaction. */
        readonly currency_code: components["schemas"]["currency_code"];
        readonly status: components["schemas"]["status-adjustment"];
        /** @description List of items on this adjustment. */
        items: ({
          /** @description Unique Paddle ID for this adjustment item, prefixed with `adjitm_`. */
          readonly id?: components["schemas"]["adjustment_item_id"];
        } & components["schemas"]["adjustment_item"])[];
        readonly totals: components["schemas"]["adjustment_totals"];
        /** @description Breakdown of how this adjustment affects your payout balance. */
        readonly payout_totals: components["schemas"]["adjustment_payout_totals"] | null;
        readonly tax_rates_used: components["schemas"]["adjustment-tax-rates-used"] | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * adjustment.updated
     * @description Occurs when an adjustment is updated.
     *
     *     This only occurs for `refund` adjustments, which must be approved by Paddle and are created as `pending_approval`
     *     initially. On review, they move to `approved` or `rejected` and `adjustment.updated` occurs.
     */
    "adjustment.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Adjustment Notification */
      data?: {
        readonly id: components["schemas"]["adjustment_id"];
        action: components["schemas"]["adjustment_action"];
        type: components["schemas"]["adjustment_type"] | null;
        /** @description Paddle ID of the transaction that this adjustment is for, prefixed with `txn_`. */
        transaction_id: components["schemas"]["transaction_id"];
        /** @description Paddle ID for the subscription related to this adjustment, prefixed with `sub_`.
         *     Set automatically by Paddle based on the `subscription_id` of the related transaction. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /** @description Paddle ID for the customer related to this adjustment, prefixed with `ctm_`.
         *     Set automatically by Paddle based on the `customer_id` of the related transaction. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Why this adjustment was created. Appears in the Paddle dashboard. Retained for recordkeeping purposes. */
        reason: string;
        /** @description Whether this adjustment was applied to the related customer's credit balance. `null` unless adjustment `action` is not `credit`. */
        readonly credit_applied_to_balance: boolean | null;
        /** @description Three-letter ISO 4217 currency code for this adjustment. Set automatically by Paddle based on the `currency_code` of the related transaction. */
        readonly currency_code: components["schemas"]["currency_code"];
        readonly status: components["schemas"]["status-adjustment"];
        /** @description List of items on this adjustment. */
        items: ({
          /** @description Unique Paddle ID for this adjustment item, prefixed with `adjitm_`. */
          readonly id?: components["schemas"]["adjustment_item_id"];
        } & components["schemas"]["adjustment_item"])[];
        readonly totals: components["schemas"]["adjustment_totals"];
        /** @description Breakdown of how this adjustment affects your payout balance. */
        readonly payout_totals: components["schemas"]["adjustment_payout_totals"] | null;
        readonly tax_rates_used: components["schemas"]["adjustment-tax-rates-used"] | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * AdjustmentAction
     * @description How this adjustment impacts the related transaction.
     * @enum {string}
     */
    adjustment_action:
      | "credit"
      | "refund"
      | "chargeback"
      | "chargeback_reverse"
      | "chargeback_warning"
      | "chargeback_warning_reverse"
      | "credit_reverse";
    /**
     * Adjustment ID
     * @description Unique Paddle ID for this adjustment entity, prefixed with `adj_`.
     */
    adjustment_id: string;
    /** Adjustment item */
    adjustment_item: {
      /** @description Paddle ID for the transaction item that this adjustment item relates to, prefixed with `txnitm_`. */
      item_id: components["schemas"]["transaction_item_id"];
      /**
       * AdjustmentItemType
       * @description Type of adjustment for this transaction item. `tax` adjustments are automatically created by Paddle.
       *     Include `amount` when creating a `partial` adjustment.
       * @enum {string}
       */
      type: "full" | "partial" | "tax" | "proration";
      /** @description Amount adjusted for this transaction item. Required when item `type` is `partial`. */
      amount?: string | null;
      /** @description How proration was calculated for this adjustment item. */
      readonly proration?: components["schemas"]["transaction_item_proration"] | null;
      readonly totals?: components["schemas"]["adjustment_item_totals"];
    };
    /**
     * Adjustment item ID
     * @description Unique Paddle ID for this adjustment item, prefixed with `adjitm_`.
     */
    adjustment_item_id: string;
    /**
     * Adjustment item totals
     * @description Breakdown of the total for an adjustment item.
     */
    adjustment_item_totals: {
      /** @description Amount multiplied by quantity. */
      readonly subtotal: string;
      /** @description Total tax on the subtotal. */
      readonly tax: string;
      /** @description Total after tax. */
      readonly total: string;
    };
    /**
     * Payout totals (adjustment)
     * @description Breakdown of how this adjustment affects your payout balance.
     */
    adjustment_payout_totals: {
      /** @description Adjustment total before tax and fees. */
      subtotal: string;
      /** @description Total tax on the adjustment subtotal. */
      tax: string;
      /** @description Adjustment total after tax. */
      total: string;
      /** @description Adjusted Paddle fee. */
      fee: string;
      /** @description Chargeback fees incurred for this adjustment. Only returned when the adjustment `action` is `chargeback` or `chargeback_warning`. */
      chargeback_fee: {
        /** @description Chargeback fee converted into the payout currency. */
        amount: string;
        /** @description Chargeback fee before conversion to the payout currency. `null` when the chargeback fee is the same as the payout currency. */
        original: {
          /** @description Fee amount for this chargeback in the original currency. */
          amount: string;
          /** @description Three-letter ISO 4217 currency code for the original chargeback fee. */
          currency_code: components["schemas"]["currency_code-chargeback"];
        } | null;
      };
      /** @description Adjusted payout earnings. This is the adjustment total plus adjusted Paddle fees, excluding chargeback fees. */
      earnings: string;
      /** @description Three-letter ISO 4217 currency code used for the payout for this transaction. If your primary currency has changed, this reflects the primary currency at the time the transaction was billed. */
      currency_code: components["schemas"]["currency_code-payout"];
    };
    /**
     * Tax mode
     * @description Whether the amounts to be adjusted are inclusive or exclusive of tax. If `internal`, adjusted amounts are considered to be inclusive of tax. If `external`, Paddle calculates the tax and adds it to the amounts provided.
     *
     *     Only valid for adjustments where the `type` is `partial`.
     *
     *     If omitted, defaults to `internal`.
     * @default internal
     * @enum {string}
     */
    adjustment_tax_mode: "external" | "internal";
    /**
     * AdjustmentTotals
     * @description Breakdown of the total for an adjustment.
     */
    adjustment_totals: {
      /** @description Total before tax. For tax adjustments, the value is 0. */
      readonly subtotal: string;
      /** @description Total tax on the subtotal. */
      readonly tax: string;
      /** @description Total after tax. */
      readonly total: string;
      /** @description Total fee taken by Paddle for this adjustment. */
      readonly fee: string;
      /** @description Total earnings. This is the subtotal minus the Paddle fee.
       *     For tax adjustments, this value is negative, which means a positive effect in the transaction earnings.
       *     This is because the fee is originally calculated from the transaction total, so if a tax adjustment is made,
       *     then the fee portion of it is returned. */
      readonly earnings: string;
      /** @description Three-letter ISO 4217 currency code used for this adjustment. */
      readonly currency_code: components["schemas"]["currency_code"];
    };
    /**
     * AdjustmentType
     * @description Type of adjustment. Use `full` to adjust the grand total for the related transaction. Include an `items` array when creating a `partial` adjustment. If omitted, defaults to `partial`.
     * @default partial
     * @enum {string}
     */
    adjustment_type: "full" | "partial";
    /**
     * api_key.created
     * @description Occurs when an API key is created.
     */
    "api_key.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** API Key Notification */
      data?: {
        id: components["schemas"]["api_key_id"];
        name: components["schemas"]["apikey-name"];
        description: components["schemas"]["apikey-description"] | null;
        key: components["schemas"]["apikey-secret-redacted"];
        status: components["schemas"]["apikey-status"];
        /** @description Permissions assigned to this API key. Determines what actions the API key can perform. */
        permissions: components["schemas"]["apikey-permission"][];
        /** @description RFC 3339 datetime string of when this API key expires. */
        expires_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this API key was last used (accurate to within 1 hour). `null` if never used. */
        last_used_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * api_key.expired
     * @description Occurs when a private API key has expired.
     */
    "api_key.expired": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** API Key Notification */
      data?: {
        id: components["schemas"]["api_key_id"];
        name: components["schemas"]["apikey-name"];
        description: components["schemas"]["apikey-description"] | null;
        key: components["schemas"]["apikey-secret-redacted"];
        status: components["schemas"]["apikey-status"];
        /** @description Permissions assigned to this API key. Determines what actions the API key can perform. */
        permissions: components["schemas"]["apikey-permission"][];
        /** @description RFC 3339 datetime string of when this API key expires. */
        expires_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this API key was last used (accurate to within 1 hour). `null` if never used. */
        last_used_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * api_key.expiring
     * @description Occurs when an API key expires in 7 days.
     */
    "api_key.expiring": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** API Key Notification */
      data?: {
        id: components["schemas"]["api_key_id"];
        name: components["schemas"]["apikey-name"];
        description: components["schemas"]["apikey-description"] | null;
        key: components["schemas"]["apikey-secret-redacted"];
        status: components["schemas"]["apikey-status"];
        /** @description Permissions assigned to this API key. Determines what actions the API key can perform. */
        permissions: components["schemas"]["apikey-permission"][];
        /** @description RFC 3339 datetime string of when this API key expires. */
        expires_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this API key was last used (accurate to within 1 hour). `null` if never used. */
        last_used_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * api_key.exposed
     * @description Occurs when an API key has been exposed.
     */
    "api_key.exposed": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** API Key Notification */
      data?: {
        id: components["schemas"]["api_key_id"];
        name: components["schemas"]["apikey-name"];
        description: components["schemas"]["apikey-description"] | null;
        key: components["schemas"]["apikey-secret-redacted"];
        status: components["schemas"]["apikey-status"];
        /** @description Permissions assigned to this API key. Determines what actions the API key can perform. */
        permissions: components["schemas"]["apikey-permission"][];
        /** @description RFC 3339 datetime string of when this API key expires. */
        expires_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this API key was last used (accurate to within 1 hour). `null` if never used. */
        last_used_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * api_key.revoked
     * @description Occurs when an API key has been revoked.
     */
    "api_key.revoked": components["schemas"]["event"] & {
      notification_id?: components["schemas"]["notification_id"];
      /** API Key Notification */
      data?: {
        id: components["schemas"]["api_key_id"];
        name: components["schemas"]["apikey-name"];
        description: components["schemas"]["apikey-description"] | null;
        key: components["schemas"]["apikey-secret-redacted"];
        status: components["schemas"]["apikey-status"];
        /** @description Permissions assigned to this API key. Determines what actions the API key can perform. */
        permissions: components["schemas"]["apikey-permission"][];
        /** @description RFC 3339 datetime string of when this API key expires. */
        expires_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this API key was last used (accurate to within 1 hour). `null` if never used. */
        last_used_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * api_key.updated
     * @description Occurs when an API key is updated.
     */
    "api_key.updated": components["schemas"]["event"] & {
      notification_id?: components["schemas"]["notification_id"];
      /** API Key Notification */
      data?: {
        id: components["schemas"]["api_key_id"];
        name: components["schemas"]["apikey-name"];
        description: components["schemas"]["apikey-description"] | null;
        key: components["schemas"]["apikey-secret-redacted"];
        status: components["schemas"]["apikey-status"];
        /** @description Permissions assigned to this API key. Determines what actions the API key can perform. */
        permissions: components["schemas"]["apikey-permission"][];
        /** @description RFC 3339 datetime string of when this API key expires. */
        expires_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this API key was last used (accurate to within 1 hour). `null` if never used. */
        last_used_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * API Key ID
     * @description Unique Paddle ID for this API key entity, prefixed with `apikey_`.
     */
    api_key_id: string;
    /**
     * ApiKeyDescription
     * @description Short description of this API key. Typically gives details about what the API key is used for and where it's used.
     */
    "apikey-description": string;
    /**
     * ApiKeyName
     * @description Short name of this API key. Typically unique and human-identifiable.
     */
    "apikey-name": string;
    /**
     * ApiKeyPermission
     * @description Permission assigned to this API key.
     */
    "apikey-permission": string & components["schemas"]["permission"];
    /**
     * ApiKeySecret
     * @description An API key, prefixed with `pdl_` and containing `_apikey_ `.
     */
    "apikey-secret": string;
    /**
     * ApiKeySecretRedacted
     * @description An obfuscated version of this API key, prefixed with `pdl_` and containing `_apikey_ `.
     */
    "apikey-secret-redacted": string;
    /**
     * ApiKeyStatus
     * @description Status of this API key.
     * @default active
     * @enum {string}
     */
    "apikey-status": "active" | "expired" | "revoked";
    /**
     * Billing details
     * @description Details for invoicing. Required if `collection_mode` is `manual`.
     */
    billing_details: {
      /**
       * @description Whether the related transaction may be paid using Paddle Checkout. If omitted when creating a transaction, defaults to `false`.
       * @default false
       */
      enable_checkout?: boolean;
      /** @description Customer purchase order number. Appears on invoice documents. */
      purchase_order_number?: string;
      /** @description Notes or other information to include on this invoice. Appears on invoice documents. */
      additional_information?: string | null;
      /** @description How long a customer has to pay this invoice once issued. */
      payment_terms: components["schemas"]["duration"];
    };
    /**
     * Billing details (update)
     * @description Details for invoicing. Required if `collection_mode` is `manual`.
     */
    billing_details_update: {
      /**
       * @description Whether the related transaction may be paid using Paddle Checkout.
       * @default false
       */
      enable_checkout: boolean;
      /** @description Customer purchase order number. Appears on invoice documents. */
      purchase_order_number: string;
      /** @description Notes or other information to include on this invoice. Appears on invoice documents. */
      additional_information: string | null;
      /** @description How long a customer has to pay this invoice once issued. */
      payment_terms: components["schemas"]["duration"];
    };
    /**
     * Business
     * @description Represents a business entity.
     */
    business: {
      readonly id: components["schemas"]["business_id"];
      /** @description Paddle ID for the customer related to this business, prefixed with `cus_`. */
      readonly customer_id: components["schemas"]["customer_id"];
      /** @description Name of this business. */
      name: components["schemas"]["name"];
      /** @description Company number for this business. */
      company_number: string | null;
      /** @description Tax or VAT Number for this business. */
      tax_identifier: string | null;
      /** @default active */
      status: components["schemas"]["status"];
      /** @description List of contacts related to this business, typically used for sending invoices. */
      contacts: {
        /** @description Full name of this contact. */
        name: components["schemas"]["name"];
        /** @description Email address for this contact. */
        email: components["schemas"]["email"];
      }[];
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
    };
    /**
     * BusinessCreate
     * @description Represents a business entity when creating businesses.
     */
    "business-create": {
      readonly id?: components["schemas"]["business_id"];
      /** @description Name of this business. */
      name: components["schemas"]["name"];
      /** @description Company number for this business. */
      company_number?: string | null;
      /** @description Tax or VAT Number for this business. */
      tax_identifier?: string | null;
      /** @description List of contacts related to this business, typically used for sending invoices. */
      contacts?:
        | {
            /** @description Full name of this contact. */
            name?: components["schemas"]["name"];
            /** @description Email address for this contact. */
            email: components["schemas"]["email"];
          }[]
        | null;
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta?: components["schemas"]["import_meta"] | null;
    };
    /**
     * BusinessUpdate
     * @description Represents a business entity when updating businesses.
     */
    "business-update": {
      /** @description Name of this business. */
      name: components["schemas"]["name"];
      /** @description Company number for this business. */
      company_number: string | null;
      /** @description Tax or VAT Number for this business. */
      tax_identifier: string | null;
      status: components["schemas"]["status"];
      /** @description List of contacts related to this business, typically used for sending invoices. */
      contacts:
        | {
            /** @description Full name of this contact. */
            name?: components["schemas"]["name"];
            /** @description Email address for this contact. */
            email: components["schemas"]["email"];
          }[]
        | null;
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
    };
    /**
     * business.created
     * @description Occurs when a business is created.
     */
    "business.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Business Notification */
      data?: {
        readonly id: components["schemas"]["business_id"];
        /** @description Paddle ID for the customer related to this business, prefixed with `cus_`. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Name of this business. */
        name: components["schemas"]["name"];
        /** @description Company number for this business. */
        company_number: string | null;
        /** @description Tax or VAT Number for this business. */
        tax_identifier: string | null;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description List of contacts related to this business, typically used for sending invoices. */
        contacts: {
          /** @description Full name of this contact. */
          name: components["schemas"]["name"];
          /** @description Email address for this contact. */
          email: components["schemas"]["email"];
        }[];
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * business.imported
     * @description Occurs when a business is imported.
     */
    "business.imported": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Business Notification */
      data?: {
        readonly id: components["schemas"]["business_id"];
        /** @description Paddle ID for the customer related to this business, prefixed with `cus_`. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Name of this business. */
        name: components["schemas"]["name"];
        /** @description Company number for this business. */
        company_number: string | null;
        /** @description Tax or VAT Number for this business. */
        tax_identifier: string | null;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description List of contacts related to this business, typically used for sending invoices. */
        contacts: {
          /** @description Full name of this contact. */
          name: components["schemas"]["name"];
          /** @description Email address for this contact. */
          email: components["schemas"]["email"];
        }[];
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * business.updated
     * @description Occurs when a business is updated.
     */
    "business.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Business Notification */
      data?: {
        readonly id: components["schemas"]["business_id"];
        /** @description Paddle ID for the customer related to this business, prefixed with `cus_`. */
        readonly customer_id: components["schemas"]["customer_id"];
        /** @description Name of this business. */
        name: components["schemas"]["name"];
        /** @description Company number for this business. */
        company_number: string | null;
        /** @description Tax or VAT Number for this business. */
        tax_identifier: string | null;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description List of contacts related to this business, typically used for sending invoices. */
        contacts: {
          /** @description Full name of this contact. */
          name: components["schemas"]["name"];
          /** @description Email address for this contact. */
          email: components["schemas"]["email"];
        }[];
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * Business ID
     * @description Unique Paddle ID for this business entity, prefixed with `biz_`.
     */
    business_id: string;
    /**
     * Card
     * @description Card metadata
     */
    card: {
      type: components["schemas"]["card_type"];
      last4: components["schemas"]["card_last4"];
      expiry_month: components["schemas"]["card_expiry_month"];
      expiry_year: components["schemas"]["card_expiry_year"];
      cardholder_name: components["schemas"]["card_cardholder_name"];
    };
    /**
     * Cardholder Name
     * @description The name on the card used to pay.
     */
    card_cardholder_name: string;
    /**
     * Card Expiry Month
     * @description Month of the expiry date of the card used to pay.
     */
    card_expiry_month: number;
    /**
     * Card Expiry Year
     * @description Year of the expiry date of the card used to pay.
     */
    card_expiry_year: number;
    /**
     * Card Last Four
     * @description Last four digits of the card used to pay.
     */
    card_last4: string;
    /**
     * CardType
     * @description Type of credit or debit card used to pay.
     * @enum {string}
     */
    card_type:
      | "american_express"
      | "diners_club"
      | "discover"
      | "jcb"
      | "mada"
      | "maestro"
      | "mastercard"
      | "union_pay"
      | "unknown"
      | "visa";
    /**
     * CatalogType
     * @description Type of item. Standard items are considered part of your catalog and are shown in the Paddle dashboard.
     * @default standard
     * @enum {string}
     */
    "catalog-type": "custom" | "standard";
    /**
     * Collection mode
     * @description How payment is collected. `automatic` for checkout, `manual` for invoices.
     * @default automatic
     * @enum {string}
     */
    collection_mode: "automatic" | "manual";
    /**
     * Country code
     * @description Two-letter ISO 3166-1 alpha-2 country code.
     */
    country_code: components["schemas"]["country_code_supported"];
    /**
     * Country code (supported)
     * @description Two-letter ISO 3166-1 alpha-2 representation of a supported country.
     * @enum {string}
     */
    country_code_supported:
      | "AD"
      | "AE"
      | "AG"
      | "AI"
      | "AL"
      | "AM"
      | "AO"
      | "AR"
      | "AS"
      | "AT"
      | "AU"
      | "AW"
      | "AX"
      | "AZ"
      | "BA"
      | "BB"
      | "BD"
      | "BE"
      | "BF"
      | "BG"
      | "BH"
      | "BI"
      | "BJ"
      | "BL"
      | "BM"
      | "BN"
      | "BO"
      | "BQ"
      | "BR"
      | "BS"
      | "BT"
      | "BV"
      | "BW"
      | "BZ"
      | "CA"
      | "CC"
      | "CG"
      | "CH"
      | "CI"
      | "CK"
      | "CL"
      | "CM"
      | "CN"
      | "CO"
      | "CR"
      | "CV"
      | "CW"
      | "CX"
      | "CY"
      | "CZ"
      | "DE"
      | "DJ"
      | "DK"
      | "DM"
      | "DO"
      | "DZ"
      | "EC"
      | "EE"
      | "EG"
      | "EH"
      | "ER"
      | "ES"
      | "ET"
      | "FI"
      | "FJ"
      | "FK"
      | "FM"
      | "FO"
      | "FR"
      | "GA"
      | "GB"
      | "GD"
      | "GE"
      | "GF"
      | "GG"
      | "GH"
      | "GI"
      | "GL"
      | "GM"
      | "GN"
      | "GP"
      | "GQ"
      | "GR"
      | "GS"
      | "GT"
      | "GU"
      | "GW"
      | "GY"
      | "HK"
      | "HM"
      | "HN"
      | "HR"
      | "HU"
      | "ID"
      | "IE"
      | "IL"
      | "IM"
      | "IN"
      | "IO"
      | "IQ"
      | "IS"
      | "IT"
      | "JE"
      | "JM"
      | "JO"
      | "JP"
      | "KE"
      | "KG"
      | "KH"
      | "KI"
      | "KM"
      | "KN"
      | "KR"
      | "KW"
      | "KY"
      | "KZ"
      | "LA"
      | "LB"
      | "LC"
      | "LI"
      | "LK"
      | "LR"
      | "LS"
      | "LT"
      | "LU"
      | "LV"
      | "MA"
      | "MC"
      | "MD"
      | "ME"
      | "MF"
      | "MG"
      | "MH"
      | "MK"
      | "MN"
      | "MO"
      | "MP"
      | "MQ"
      | "MR"
      | "MS"
      | "MT"
      | "MU"
      | "MV"
      | "MW"
      | "MX"
      | "MY"
      | "MZ"
      | "NA"
      | "NC"
      | "NE"
      | "NF"
      | "NG"
      | "NL"
      | "NO"
      | "NP"
      | "NR"
      | "NU"
      | "NZ"
      | "OM"
      | "PA"
      | "PE"
      | "PF"
      | "PG"
      | "PH"
      | "PK"
      | "PL"
      | "PM"
      | "PN"
      | "PR"
      | "PS"
      | "PT"
      | "PW"
      | "PY"
      | "QA"
      | "RE"
      | "RO"
      | "RS"
      | "RW"
      | "SA"
      | "SB"
      | "SC"
      | "SE"
      | "SG"
      | "SH"
      | "SI"
      | "SJ"
      | "SK"
      | "SL"
      | "SM"
      | "SN"
      | "SR"
      | "ST"
      | "SV"
      | "SX"
      | "SZ"
      | "TC"
      | "TD"
      | "TF"
      | "TG"
      | "TH"
      | "TJ"
      | "TK"
      | "TL"
      | "TM"
      | "TN"
      | "TO"
      | "TR"
      | "TT"
      | "TV"
      | "TW"
      | "TZ"
      | "UA"
      | "UG"
      | "UM"
      | "US"
      | "UY"
      | "UZ"
      | "VA"
      | "VC"
      | "VG"
      | "VI"
      | "VN"
      | "VU"
      | "WF"
      | "WS"
      | "XK"
      | "YT"
      | "ZA"
      | "ZM";
    /**
     * Created at
     * Format: date-time
     * @description RFC 3339 datetime string of when this entity was created. Set automatically by Paddle.
     */
    created_at: string;
    /**
     * credit_balance
     * @description Represents a credit balance for a customer.
     */
    credit_balance: {
      /** @description Paddle ID of the customer that this credit balance is for, prefixed with `ctm_`. */
      customer_id: components["schemas"]["customer_id"];
      /** @description Three-letter ISO 4217 currency code for this credit balance. */
      currency_code: components["schemas"]["currency_code"];
      /** @description Totals for this credit balance. Where a customer has more than one subscription in this currency with a credit balance, includes totals for all subscriptions. */
      balance: components["schemas"]["customer_balance"];
    };
    /**
     * Currency code
     * @description Supported three-letter ISO 4217 currency code.
     * @enum {string}
     */
    currency_code:
      | "USD"
      | "EUR"
      | "GBP"
      | "JPY"
      | "AUD"
      | "CAD"
      | "CHF"
      | "HKD"
      | "SGD"
      | "SEK"
      | "ARS"
      | "BRL"
      | "CNY"
      | "COP"
      | "CZK"
      | "DKK"
      | "HUF"
      | "ILS"
      | "INR"
      | "KRW"
      | "MXN"
      | "NOK"
      | "NZD"
      | "PLN"
      | "RUB"
      | "THB"
      | "TRY"
      | "TWD"
      | "UAH"
      | "VND"
      | "ZAR";
    /**
     * Currency code (chargebacks)
     * @description Three-letter ISO 4217 currency code for chargeback fees.
     * @enum {string}
     */
    "currency_code-chargeback": "AUD" | "CAD" | "EUR" | "GBP" | "USD";
    /**
     * Currency code (payouts)
     * @description Supported three-letter ISO 4217 currency code for payouts from Paddle.
     * @enum {string}
     */
    "currency_code-payout":
      | "AUD"
      | "CAD"
      | "CHF"
      | "CNY"
      | "CZK"
      | "DKK"
      | "EUR"
      | "GBP"
      | "HUF"
      | "PLN"
      | "SEK"
      | "USD"
      | "ZAR";
    /**
     * Custom data
     * @description Your own structured key-value data.
     */
    custom_data: {
      [key: string]: unknown;
    };
    /**
     * Customer
     * @description Represents a customer entity.
     */
    customer: {
      readonly id: components["schemas"]["customer_id"];
      /** @description Full name of this customer. Required when creating transactions where `collection_mode` is `manual` (invoices). */
      name: components["schemas"]["name"] | null;
      /** @description Email address for this customer. */
      email: components["schemas"]["email"];
      /**
       * @description Whether this customer opted into marketing from you. `false` unless customers check the marketing consent box
       *     when using Paddle Checkout. Set automatically by Paddle.
       * @default false
       */
      readonly marketing_consent: boolean;
      /** @default active */
      status: components["schemas"]["status"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /**
       * @description Valid IETF BCP 47 short form locale tag. If omitted, defaults to `en`.
       * @default en
       */
      locale: string;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
    };
    /**
     * CustomerCreate
     * @description Represents a customer entity when creating customers.
     */
    "customer-create": {
      readonly id?: components["schemas"]["customer_id"];
      /** @description Full name of this customer. Required when creating transactions where `collection_mode` is `manual` (invoices). */
      name?: components["schemas"]["name"] | null;
      /** @description Email address for this customer. */
      email: components["schemas"]["email"];
      /**
       * @description Whether this customer opted into marketing from you. `false` unless customers check the marketing consent box
       *     when using Paddle Checkout. Set automatically by Paddle.
       * @default false
       */
      readonly marketing_consent?: boolean;
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
      /**
       * @description Valid IETF BCP 47 short form locale tag. If omitted, defaults to `en`.
       * @default en
       */
      locale?: string;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta?: components["schemas"]["import_meta"] | null;
    };
    /**
     * CustomerIncludes
     * @description Represents a customer entity with included entities.
     */
    "customer-includes": components["schemas"]["customer"] & unknown;
    /**
     * Payment Method
     * @description Represents a customer payment method entity.
     */
    "customer-payment-method": {
      id: components["schemas"]["payment_method_id"];
      /** @description Paddle ID of the customer that this payment method is saved for, prefixed with `ctm_`. */
      customer_id: components["schemas"]["customer_id"];
      /** @description Paddle ID of the address for this payment method, prefixed with `add_`. */
      address_id: components["schemas"]["address_id"];
      /**
       * SavedPaymentMethodType
       * @description Type of payment method saved.
       * @enum {string}
       */
      type: "alipay" | "apple_pay" | "card" | "google_pay" | "korea_local" | "paypal";
      /** @description Information about the credit or debit card saved. `null` unless `type` is `card`. */
      card: components["schemas"]["card"] | null;
      /** @description Information about the PayPal payment method saved. `null` unless `type` is `paypal`. */
      paypal: components["schemas"]["paypal"] | null;
      readonly underlying_details: components["schemas"]["underlying_details"] | null;
      /**
       * PaymentMethodOrigin
       * @description Describes how this payment method was saved.
       * @enum {string}
       */
      origin: "saved_during_purchase" | "subscription";
      saved_at: components["schemas"]["saved_at"];
      updated_at: components["schemas"]["updated_at"];
    };
    /**
     * Customer Portal Session
     * @description Represents a customer portal session.
     */
    "customer-portal-session": {
      readonly id: components["schemas"]["customer-portal-session-id"];
      /** @description Paddle ID of the customer that this customer portal sessions is for, prefixed with `ctm_`. */
      customer_id?: components["schemas"]["customer_id"];
      /**
       * CustomerPortalSessionUrls
       * @description Authenticated customer portal deep links. For security, the `token` appended to each link is temporary. You shouldn't store these links.
       */
      urls: {
        /**
         * CustomerPortalSessionGeneralUrls
         * @description Authenticated customer portal deep links that aren't associated with a specific entity.
         */
        general: {
          /** @description Link to the overview page in the customer portal. */
          overview: string;
        };
        /** @description List of generated authenticated customer portal deep links for the subscriptions passed in the `subscription_ids` array in the request.
         *
         *     If subscriptions are paused or canceled, links open the overview page for a subscription.
         *
         *     Empty if no subscriptions passed in the request. */
        subscriptions?: {
          /** @description Paddle ID of the subscription that the authenticated customer portal deep links are for. */
          id: components["schemas"]["subscription_id"];
          /** @description Link to the page for this subscription in the customer portal with the subscription cancellation form pre-opened. Use as part of cancel subscription workflows. */
          cancel_subscription: string;
          /** @description Link to the page for this subscription in the customer portal with the payment method update form pre-opened. Use as part of workflows to let customers update their payment details.
           *
           *     If a manually-collected subscription, opens the overview page for this subscription. */
          update_subscription_payment_method: string;
        }[];
      };
      /** @description RFC 3339 datetime string of when this customer portal session was created. */
      created_at: components["schemas"]["timestamp"];
    };
    /**
     * CustomerPortalSessionCreate
     * @description Represents a customer portal session creation request.
     */
    "customer-portal-session-create": {
      /** @description List of subscriptions to create authenticated customer portal deep links for. */
      subscription_ids: components["schemas"]["subscription_id"][];
    };
    /**
     * Customer Portal Session ID
     * @description Unique Paddle ID for this customer portal session entity, prefixed with `cpls_`.
     */
    "customer-portal-session-id": string;
    /**
     * CustomerUpdate
     * @description Represents a customer entity when updating customers.
     */
    "customer-update": {
      /** @description Full name of this customer. Required when creating transactions where `collection_mode` is `manual` (invoices). */
      name: components["schemas"]["name"] | null;
      /** @description Email address for this customer. */
      email: components["schemas"]["email"];
      /**
       * @description Whether this customer opted into marketing from you. `false` unless customers check the marketing consent box
       *     when using Paddle Checkout. Set automatically by Paddle.
       * @default false
       */
      readonly marketing_consent: boolean;
      status: components["schemas"]["status"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /**
       * @description Valid IETF BCP 47 short form locale tag.
       * @default en
       */
      locale: string;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
    };
    /**
     * customer.created
     * @description Occurs when a customer is created.
     */
    "customer.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Customer Notification */
      data?: {
        readonly id: components["schemas"]["customer_id"];
        /** @description Full name of this customer. Required when creating transactions where `collection_mode` is `manual` (invoices). */
        name: components["schemas"]["name"] | null;
        /** @description Email address for this customer. */
        email: components["schemas"]["email"];
        /**
         * @description Whether this customer opted into marketing from you. `false` unless customers check the marketing consent box
         *     when using Paddle Checkout. Set automatically by Paddle.
         * @default false
         */
        readonly marketing_consent: boolean;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /**
         * @description Valid IETF BCP 47 short form locale tag.
         * @default en
         */
        locale: string;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * customer.imported
     * @description Occurs when a customer is imported.
     */
    "customer.imported": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Customer Notification */
      data?: {
        readonly id: components["schemas"]["customer_id"];
        /** @description Full name of this customer. Required when creating transactions where `collection_mode` is `manual` (invoices). */
        name: components["schemas"]["name"] | null;
        /** @description Email address for this customer. */
        email: components["schemas"]["email"];
        /**
         * @description Whether this customer opted into marketing from you. `false` unless customers check the marketing consent box
         *     when using Paddle Checkout. Set automatically by Paddle.
         * @default false
         */
        readonly marketing_consent: boolean;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /**
         * @description Valid IETF BCP 47 short form locale tag.
         * @default en
         */
        locale: string;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * customer.updated
     * @description Occurs when a customer is updated.
     */
    "customer.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Customer Notification */
      data?: {
        readonly id: components["schemas"]["customer_id"];
        /** @description Full name of this customer. Required when creating transactions where `collection_mode` is `manual` (invoices). */
        name: components["schemas"]["name"] | null;
        /** @description Email address for this customer. */
        email: components["schemas"]["email"];
        /**
         * @description Whether this customer opted into marketing from you. `false` unless customers check the marketing consent box
         *     when using Paddle Checkout. Set automatically by Paddle.
         * @default false
         */
        readonly marketing_consent: boolean;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /**
         * @description Valid IETF BCP 47 short form locale tag.
         * @default en
         */
        locale: string;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * Customer Auth Token
     * @description Authentication token generated by Paddle for this customer. Pass to Paddle.js when opening a checkout to let customers work with saved payment methods.
     */
    customer_auth_token: string;
    /**
     * Customer Authentication Token
     * @description Represents a customer authentication token.
     */
    customer_authentication_token: {
      customer_auth_token: components["schemas"]["customer_auth_token"];
      /** @description RFC 3339 datetime string of when this customer authentication token expires. The token is no longer valid after this date. */
      expires_at?: components["schemas"]["timestamp"];
    };
    /** customer_balance */
    customer_balance: {
      /** @description Total amount of credit available to use. */
      available: string;
      /** @description Total amount of credit temporarily reserved for `billed` transactions. */
      reserved: string;
      /** @description Total amount of credit used. */
      used: string;
    };
    /**
     * Customer ID
     * @description Unique Paddle ID for this customer entity, prefixed with `ctm_`.
     */
    customer_id: string;
    /**
     * Discount
     * @description Represents a discount entity.
     */
    discount: {
      readonly id: components["schemas"]["discount_id"];
      /** @default active */
      status: components["schemas"]["status-discount"];
      /** @description Short description for this discount for your reference. Not shown to customers. */
      description: string;
      /**
       * @description Whether this discount can be redeemed by customers at checkout (`true`) or not (`false`).
       * @default true
       */
      enabled_for_checkout: boolean;
      /** @description Unique code that customers can use to redeem this discount at checkout. Not case-sensitive. */
      code: components["schemas"]["discount_code"] | null;
      /**
       * DiscountType
       * @description Type of discount. Determines how this discount impacts the checkout or transaction total.
       * @enum {string}
       */
      type: "flat" | "flat_per_seat" | "percentage";
      mode: components["schemas"]["discount_mode"];
      /** @description Amount to discount by. For `percentage` discounts, must be an amount between `0.01` and `100`. For `flat` and `flat_per_seat` discounts, amount in the lowest denomination for a currency. */
      amount: string;
      /** @description Supported three-letter ISO 4217 currency code. Required where discount type is `flat` or `flat_per_seat`. */
      currency_code: components["schemas"]["currency_code"] | null;
      /**
       * @description Whether this discount applies for multiple subscription billing periods (`true`) or not (`false`).
       * @default false
       */
      recur: boolean;
      /** @description Number of subscription billing periods that this discount recurs for. Requires `recur`. `null` if this discount recurs forever.
       *
       *     Subscription renewals, midcycle changes, and one-time charges billed to a subscription aren't considered a redemption. `times_used` is not incremented in these cases. */
      maximum_recurring_intervals: number | null;
      /** @description Maximum number of times this discount can be redeemed. This is an overall limit for this discount, rather than a per-customer limit. `null` if this discount can be redeemed an unlimited amount of times.
       *
       *     Paddle counts a usage as a redemption on a checkout, transaction, or the initial application against a subscription. Transactions created for subscription renewals, midcycle changes, and one-time charges aren't considered a redemption. */
      usage_limit: number | null;
      /** @description Product or price IDs that this discount is for. When including a product ID, all prices for that product can be discounted. `null` if this discount applies to all products and prices. */
      restrict_to: string[] | null;
      /** @description RFC 3339 datetime string of when this discount expires. Discount can no longer be redeemed after this date has elapsed. `null` if this discount can be redeemed forever.
       *
       *     Expired discounts can't be redeemed against transactions or checkouts, but can be applied when updating subscriptions. */
      expires_at: components["schemas"]["timestamp"] | null;
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description How many times this discount has been redeemed. Automatically incremented by Paddle.
       *
       *     Paddle counts a usage as a redemption on a checkout, transaction, or subscription. Transactions created for subscription renewals, midcycle changes, and one-time charges aren't considered a redemption. */
      readonly times_used: number;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
    };
    /**
     * DiscountCreate
     * @description Represents a discount entity when creating discounts.
     */
    "discount-create": {
      readonly id?: components["schemas"]["discount_id"];
      /** @default active */
      readonly status?: components["schemas"]["status-discount"];
      /** @description Short description for this discount for your reference. Not shown to customers. */
      description: string;
      /**
       * @description Whether this discount can be redeemed by customers at checkout (`true`) or not (`false`).
       * @default true
       */
      enabled_for_checkout?: boolean;
      /** @description Unique code that customers can use to redeem this discount at checkout. Use letters and numbers only, up to 32 characters. Not case-sensitive.
       *
       *     If omitted and `enabled_for_checkout` is `true`, Paddle generates a random 10-character code. */
      code?: components["schemas"]["discount_code"] | null;
      /**
       * DiscountType
       * @description Type of discount. Determines how this discount impacts the checkout or transaction total.
       * @enum {string}
       */
      type: "flat" | "flat_per_seat" | "percentage";
      /** @description Discount mode. Standard discounts are considered part of your catalog and are shown in the Paddle dashboard. If omitted, defaults to `standard`. */
      mode?: components["schemas"]["discount_mode"];
      /** @description Amount to discount by. For `percentage` discounts, must be an amount between `0.01` and `100`. For `flat` and `flat_per_seat` discounts, amount in the lowest denomination for a currency. */
      amount: string;
      /** @description Supported three-letter ISO 4217 currency code. Required where discount type is `flat` or `flat_per_seat`. */
      currency_code?: components["schemas"]["currency_code"] | null;
      /**
       * @description Whether this discount applies for multiple subscription billing periods (`true`) or not (`false`). If omitted, defaults to `false`.
       * @default false
       */
      recur?: boolean;
      /** @description Number of subscription billing periods that this discount recurs for. Requires `recur`. `null` if this discount recurs forever.
       *
       *     Subscription renewals, midcycle changes, and one-time charges billed to a subscription aren't considered a redemption. `times_used` is not incremented in these cases. */
      maximum_recurring_intervals?: number | null;
      /** @description Maximum number of times this discount can be redeemed. This is an overall limit for this discount, rather than a per-customer limit. `null` if this discount can be redeemed an unlimited amount of times.
       *
       *     Paddle counts a usage as a redemption on a checkout, transaction, or the initial application against a subscription. Transactions created for subscription renewals, midcycle changes, and one-time charges aren't considered a redemption. */
      usage_limit?: number | null;
      /** @description Product or price IDs that this discount is for. When including a product ID, all prices for that product can be discounted. `null` if this discount applies to all products and prices. */
      restrict_to?: string[] | null;
      /** @description RFC 3339 datetime string of when this discount expires. Discount can no longer be redeemed after this date has elapsed. `null` if this discount can be redeemed forever.
       *
       *     Expired discounts can't be redeemed against transactions or checkouts, but can be applied when updating subscriptions. */
      expires_at?: components["schemas"]["timestamp"] | null;
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
      /** @description How many times this discount has been redeemed. Automatically incremented by Paddle.
       *
       *     Paddle counts a usage as a redemption on a checkout, transaction, or subscription. Transactions created for subscription renewals, midcycle changes, and one-time charges aren't considered a redemption. */
      readonly times_used?: number;
      readonly created_at?: components["schemas"]["created_at"];
      readonly updated_at?: components["schemas"]["updated_at"];
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta?: components["schemas"]["import_meta"] | null;
    };
    /**
     * SubscriptionDiscountTimePeriod
     * @description Details of the discount applied to this subscription.
     */
    "discount-subscription": {
      id: components["schemas"]["discount_id"];
      /** @description RFC 3339 datetime string of when this discount was first applied. `null` for canceled subscriptions where a discount was redeemed but never applied to a transaction. */
      starts_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this discount no longer applies. Where a discount has `maximum_recurring_intervals`, this is the date of the last billing period where this discount applies. `null` where a discount recurs forever. */
      ends_at: components["schemas"]["timestamp"] | null;
    };
    /**
     * discount.created
     * @description Occurs when a discount is created.
     *
     *     Payload includes the complete discount entity, except `times_used`. This field changes frequently, so isn't included in payloads. [Get a discount using the API](/api-reference/discounts/get-discount) to see the latest value.
     */
    "discount.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Discount Notification */
      data?: {
        readonly id: components["schemas"]["discount_id"];
        status: components["schemas"]["status-discount"];
        /** @description Short description for this discount for your reference. Not shown to customers. */
        description: string;
        /**
         * @description Whether this discount can be redeemed by customers at checkout (`true`) or not (`false`).
         * @default true
         */
        enabled_for_checkout: boolean;
        /** @description Unique code that customers can use to redeem this discount at checkout. Not case-sensitive. */
        code: string | null;
        /**
         * DiscountType
         * @description Type of discount. Determines how this discount impacts the checkout or transaction total.
         * @enum {string}
         */
        type: "flat" | "flat_per_seat" | "percentage";
        mode: components["schemas"]["discount_mode"] | null;
        /** @description Amount to discount by. For `percentage` discounts, must be an amount between `0.01` and `100`. For `flat` and `flat_per_seat` discounts, amount in the lowest denomination for a currency. */
        amount: string;
        /** @description Supported three-letter ISO 4217 currency code. Required where discount type is `flat` or `flat_per_seat`. */
        currency_code: components["schemas"]["currency_code"] | null;
        /**
         * @description Whether this discount applies for multiple subscription billing periods (`true`) or not (`false`).
         * @default false
         */
        recur: boolean;
        /** @description Number of subscription billing periods that this discount recurs for. Requires `recur`. `null` if this discount recurs forever.
         *
         *     Subscription renewals, midcycle changes, and one-time charges billed to a subscription aren't considered a redemption. `times_used` is not incremented in these cases. */
        maximum_recurring_intervals: number | null;
        /** @description Maximum number of times this discount can be redeemed. This is an overall limit for this discount, rather than a per-customer limit. `null` if this discount can be redeemed an unlimited amount of times.
         *
         *     Paddle counts a usage as a redemption on a checkout, transaction, or the initial application against a subscription. Transactions created for subscription renewals, midcycle changes, and one-time charges aren't considered a redemption. */
        usage_limit: number | null;
        /** @description Product or price IDs that this discount is for. When including a product ID, all prices for that product can be discounted. `null` if this discount applies to all products and prices. */
        restrict_to: string[] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        import_meta: components["schemas"]["import_meta"] | null;
        /** @description RFC 3339 datetime string of when this discount expires. Discount can no longer be redeemed after this date has elapsed. `null` if this discount can be redeemed forever.
         *
         *     Expired discounts can't be redeemed against transactions or checkouts, but can be applied when updating subscriptions. */
        expires_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * discount.imported
     * @description Occurs when a discount is imported.
     *
     *     Payload includes the complete discount entity, except `times_used`. This field changes frequently, so isn't included in payloads. [Get a discount using the API](/api-reference/discounts/get-discount) to see the latest value.
     */
    "discount.imported": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Discount Notification */
      data?: {
        readonly id: components["schemas"]["discount_id"];
        status: components["schemas"]["status-discount"];
        /** @description Short description for this discount for your reference. Not shown to customers. */
        description: string;
        /**
         * @description Whether this discount can be redeemed by customers at checkout (`true`) or not (`false`).
         * @default true
         */
        enabled_for_checkout: boolean;
        /** @description Unique code that customers can use to redeem this discount at checkout. Not case-sensitive. */
        code: string | null;
        /**
         * DiscountType
         * @description Type of discount. Determines how this discount impacts the checkout or transaction total.
         * @enum {string}
         */
        type: "flat" | "flat_per_seat" | "percentage";
        mode: components["schemas"]["discount_mode"] | null;
        /** @description Amount to discount by. For `percentage` discounts, must be an amount between `0.01` and `100`. For `flat` and `flat_per_seat` discounts, amount in the lowest denomination for a currency. */
        amount: string;
        /** @description Supported three-letter ISO 4217 currency code. Required where discount type is `flat` or `flat_per_seat`. */
        currency_code: components["schemas"]["currency_code"] | null;
        /**
         * @description Whether this discount applies for multiple subscription billing periods (`true`) or not (`false`).
         * @default false
         */
        recur: boolean;
        /** @description Number of subscription billing periods that this discount recurs for. Requires `recur`. `null` if this discount recurs forever.
         *
         *     Subscription renewals, midcycle changes, and one-time charges billed to a subscription aren't considered a redemption. `times_used` is not incremented in these cases. */
        maximum_recurring_intervals: number | null;
        /** @description Maximum number of times this discount can be redeemed. This is an overall limit for this discount, rather than a per-customer limit. `null` if this discount can be redeemed an unlimited amount of times.
         *
         *     Paddle counts a usage as a redemption on a checkout, transaction, or the initial application against a subscription. Transactions created for subscription renewals, midcycle changes, and one-time charges aren't considered a redemption. */
        usage_limit: number | null;
        /** @description Product or price IDs that this discount is for. When including a product ID, all prices for that product can be discounted. `null` if this discount applies to all products and prices. */
        restrict_to: string[] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        import_meta: components["schemas"]["import_meta"] | null;
        /** @description RFC 3339 datetime string of when this discount expires. Discount can no longer be redeemed after this date has elapsed. `null` if this discount can be redeemed forever.
         *
         *     Expired discounts can't be redeemed against transactions or checkouts, but can be applied when updating subscriptions. */
        expires_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * discount.updated
     * @description Occurs when a discount is updated.
     *
     *     Payload includes the complete discount entity, except `times_used`. This field changes frequently, so isn't included in payloads. [Get a discount using the API](/api-reference/discounts/get-discount) to see the latest value.
     */
    "discount.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Discount Notification */
      data?: {
        readonly id: components["schemas"]["discount_id"];
        status: components["schemas"]["status-discount"];
        /** @description Short description for this discount for your reference. Not shown to customers. Not case-sensitive. */
        description: string;
        /**
         * @description Whether this discount can be redeemed by customers at checkout (`true`) or not (`false`).
         * @default true
         */
        enabled_for_checkout: boolean;
        /** @description Unique code that customers can use to redeem this discount at checkout. */
        code: string | null;
        /**
         * DiscountType
         * @description Type of discount. Determines how this discount impacts the checkout or transaction total.
         * @enum {string}
         */
        type: "flat" | "flat_per_seat" | "percentage";
        mode: components["schemas"]["discount_mode"] | null;
        /** @description Amount to discount by. For `percentage` discounts, must be an amount between `0.01` and `100`. For `flat` and `flat_per_seat` discounts, amount in the lowest denomination for a currency. */
        amount: string;
        /** @description Supported three-letter ISO 4217 currency code. Required where discount type is `flat` or `flat_per_seat`. */
        currency_code: components["schemas"]["currency_code"] | null;
        /**
         * @description Whether this discount applies for multiple subscription billing periods (`true`) or not (`false`).
         * @default false
         */
        recur: boolean;
        /** @description Number of subscription billing periods that this discount recurs for. Requires `recur`. `null` if this discount recurs forever.
         *
         *     Subscription renewals, midcycle changes, and one-time charges billed to a subscription aren't considered a redemption. `times_used` is not incremented in these cases. */
        maximum_recurring_intervals: number | null;
        /** @description Maximum number of times this discount can be redeemed. This is an overall limit for this discount, rather than a per-customer limit. `null` if this discount can be redeemed an unlimited amount of times.
         *
         *     Paddle counts a usage as a redemption on a checkout, transaction, or the initial application against a subscription. Transactions created for subscription renewals, midcycle changes, and one-time charges aren't considered a redemption. */
        usage_limit: number | null;
        /** @description Product or price IDs that this discount is for. When including a product ID, all prices for that product can be discounted. `null` if this discount applies to all products and prices. */
        restrict_to: string[] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        import_meta: components["schemas"]["import_meta"] | null;
        /** @description RFC 3339 datetime string of when this discount expires. Discount can no longer be redeemed after this date has elapsed. `null` if this discount can be redeemed forever.
         *
         *     Expired discounts can't be redeemed against transactions or checkouts, but can be applied when updating subscriptions. */
        expires_at: components["schemas"]["timestamp"] | null;
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * Discount code
     * @description Unique code that customers can use to apply this discount at checkout. Use letters and numbers only, up to 32 characters. Not case-sensitive.
     */
    discount_code: string;
    /**
     * Discount ID
     * @description Unique Paddle ID for this discount, prefixed with `dsc_`.
     */
    discount_id: string;
    /**
     * DiscountMode
     * @description Discount mode. Standard discounts are considered part of your catalog and are shown in the Paddle dashboard.
     * @default standard
     * @enum {string}
     */
    discount_mode: "standard" | "custom";
    /** @description Document number that is automatically generated by Paddle. */
    document_number: string;
    /** Duration */
    duration: {
      /**
       * @description Unit of time.
       * @enum {string}
       */
      interval: "day" | "week" | "month" | "year";
      /** @description Amount of time. */
      frequency: number;
    };
    /**
     * Effective from
     * @description When this subscription change should take effect from. Defaults to `next_billing_period`, which creates a
     *     `scheduled_change` to apply the subscription change at the end of the billing period.
     * @enum {string}
     */
    effective_from: "next_billing_period" | "immediately";
    /**
     * Effective from
     * @description When this subscription change should take effect from. Defaults to `next_billing_period` for active subscriptions,
     *     which creates a `scheduled_change` to apply the subscription change at the end of the billing period.
     * @enum {string|null}
     */
    effective_from_nullable: "next_billing_period" | "immediately" | null;
    /**
     * Email address
     * Format: email
     * @description Email address for this entity.
     */
    email: string;
    /** Empty String */
    empty_string: string;
    /** Error */
    error: {
      /** @description Represents an error. */
      error: {
        /**
         * @description Type of error encountered.
         * @enum {string}
         */
        type: "request_error" | "api_error";
        /** @description Short snake case string that describes this error. Use to search the error reference. */
        code: string;
        /** @description Some information about what went wrong as a human-readable string. */
        detail: string;
        /**
         * Format: uri
         * @description Link to a page in the error reference for this specific error.
         */
        documentation_url: string;
        /** @description List of validation errors. Only returned when there's a validation error. */
        errors?: {
          /** @description Field where validation error occurred. */
          field: string;
          /** @description Information about how the field failed validation. */
          message: string;
        }[];
      };
      meta: components["schemas"]["meta"];
    };
    /**
     * Error code
     * @description Reason why a payment attempt failed. Returns `null` if payment captured successfully.
     * @enum {string}
     */
    error_code:
      | "already_canceled"
      | "already_refunded"
      | "authentication_failed"
      | "blocked_card"
      | "canceled"
      | "declined"
      | "declined_not_retryable"
      | "expired_card"
      | "fraud"
      | "invalid_amount"
      | "invalid_payment_details"
      | "issuer_unavailable"
      | "not_enough_balance"
      | "preferred_network_not_supported"
      | "psp_error"
      | "redacted_payment_method"
      | "system_error"
      | "transaction_not_permitted"
      | "unknown";
    /**
     * Event
     * @description Represents an event entity.
     */
    event: {
      readonly event_id: components["schemas"]["event_id"];
      readonly event_type: components["schemas"]["event_type_name"];
      /** @description RFC 3339 datetime string of when this event occurred. */
      readonly occurred_at: components["schemas"]["timestamp"];
      /** @description New or changed entity. */
      readonly data: Record<string, never>;
    };
    /**
     * Event ID
     * @description Unique Paddle ID for this event, prefixed with `evt_`.
     */
    event_id: string;
    /**
     * Event type
     * @description Represents an event type.
     */
    event_type: {
      readonly name: components["schemas"]["event_type_name"];
      /** @description Short description of this event type. */
      readonly description: string;
      /** @description Group for this event type. Typically the entity that this event relates to. */
      readonly group: string;
      /** @description List of API versions that this event type supports. */
      readonly available_versions: number[];
    };
    /**
     * Event type name
     * @description Type of event sent by Paddle, in the format `entity.event_type`.
     * @enum {string}
     */
    event_type_name:
      | "address.created"
      | "address.imported"
      | "address.updated"
      | "adjustment.created"
      | "adjustment.updated"
      | "api_key.created"
      | "api_key.expired"
      | "api_key.expiring"
      | "api_key.revoked"
      | "api_key.updated"
      | "business.created"
      | "business.imported"
      | "business.updated"
      | "customer.created"
      | "customer.imported"
      | "customer.updated"
      | "discount.created"
      | "discount.imported"
      | "discount.updated"
      | "payment_method.saved"
      | "payment_method.deleted"
      | "payout.created"
      | "payout.paid"
      | "price.created"
      | "price.imported"
      | "price.updated"
      | "product.created"
      | "product.imported"
      | "product.updated"
      | "report.created"
      | "report.updated"
      | "subscription.activated"
      | "subscription.canceled"
      | "subscription.created"
      | "subscription.imported"
      | "subscription.past_due"
      | "subscription.paused"
      | "subscription.resumed"
      | "subscription.trialing"
      | "subscription.updated"
      | "transaction.billed"
      | "transaction.canceled"
      | "transaction.completed"
      | "transaction.created"
      | "transaction.paid"
      | "transaction.past_due"
      | "transaction.payment_failed"
      | "transaction.ready"
      | "transaction.revised"
      | "transaction.updated";
    /**
     * External ID
     * @description Reference or identifier for this entity from the provider where it was imported from.
     */
    external_id: string;
    /**
     * Image Url
     * Format: uri
     * @description A URL to an image.
     */
    image_url: string;
    /**
     * ImportMeta
     * @description Import information for this entity. `null` if this entity is not imported.
     */
    import_meta: {
      external_id?: components["schemas"]["external_id"] | null;
      /** @description Name of the platform or provider where this entity was imported from. */
      imported_from: components["schemas"]["migration_provider"];
    };
    /**
     * ImportMetaSubscription
     * @description Import information for the subscription entity. `null` if this entity is not imported.
     */
    import_meta_subscription: {
      external_id?: components["schemas"]["external_id"] | null;
      /** @description Name of the platform or provider where this entity was imported from. */
      imported_from: components["schemas"]["migration_provider"];
    };
    /**
     * Subscription item
     * @description Represents a subscription item.
     */
    "item-subscription": {
      /**
       * SubscriptionItemStatus
       * @description Status of this subscription item. Set automatically by Paddle.
       * @enum {string}
       */
      readonly status: "active" | "inactive" | "trialing";
      /** @description Quantity of this item on the subscription. */
      quantity: number;
      /** @description Whether this is a recurring item. `false` if one-time. */
      readonly recurring: boolean;
      /** @description RFC 3339 datetime string of when this item was added to this subscription. */
      readonly created_at: components["schemas"]["created_at"];
      /** @description RFC 3339 datetime string of when this item was last updated on this subscription. */
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description RFC 3339 datetime string of when this item was last billed. */
      readonly previously_billed_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this item is next scheduled to be billed. */
      readonly next_billed_at: components["schemas"]["timestamp"] | null;
      /** @description Trial dates for this item. */
      readonly trial_dates: components["schemas"]["time_period"] | null;
      /** @description Related price entity for this item. This reflects the price entity at the time it was added to the subscription. */
      readonly price: components["schemas"]["price"];
      /** @description Related product entity for this item. This reflects the product entity at the time it was added to the subscription. */
      readonly product: components["schemas"]["product"];
    };
    /**
     * Korean market underlying details
     * @description Information about the Korean payment method used to pay. `null` unless the type is `korea_local`.
     */
    korea_local_underlying_details: {
      readonly type: components["schemas"]["korea_local_underlying_payment_method_type"];
    };
    /**
     * Korean market underlying payment method type
     * @description Type of Korean payment method used to pay.
     * @enum {string}
     */
    korea_local_underlying_payment_method_type:
      | "bc"
      | "citi"
      | "hana"
      | "hyundai"
      | "jeju"
      | "jeonbuk"
      | "kakaobank"
      | "kakaopay"
      | "kbank"
      | "kdbbank"
      | "kookmin"
      | "kwangju"
      | "lotte"
      | "mg"
      | "naverpaycard"
      | "naverpaypoint"
      | "nh"
      | "payco"
      | "post"
      | "samsung"
      | "samsungpay"
      | "savingsbank"
      | "shinhan"
      | "shinhyup"
      | "suhyup"
      | "tossbank"
      | "unknown"
      | "woori";
    /**
     * Meta
     * @description Information about this response.
     */
    meta: {
      request_id: components["schemas"]["request_id"];
    };
    /**
     * MetaPaginated
     * @description Information about this response.
     */
    "meta-paginated": {
      request_id: components["schemas"]["request_id"];
      pagination: components["schemas"]["pagination"];
    };
    /**
     * Method details
     * @description Information about the payment method used for a payment attempt.
     */
    method_details: {
      type: components["schemas"]["transaction_payment_method_type"];
      readonly underlying_details: components["schemas"]["underlying_details"] | null;
      /** @description Information about the credit or debit card used to pay. `null` unless `type` is `card`. */
      card: components["schemas"]["card"] | null;
    };
    /**
     * MigrationProvider
     * @description Platform or provider that a migration is from.
     */
    migration_provider: string & components["schemas"]["migration_provider_public"];
    /**
     * MigrationProviderPublic
     * @description Platform or provider that a migration is from.
     * @enum {string}
     */
    migration_provider_public: "paddle_classic";
    /**
     * Money
     * @description A base representation of monetary value unformatted in the lowest denomination with currency code.
     */
    money: {
      /** @description Amount in the lowest denomination for the currency, e.g. 10 USD = 1000 (cents). Although represented as a string, this value must be a valid integer. */
      amount: string;
      currency_code: components["schemas"]["currency_code"];
    };
    /**
     * Name
     * @description Full name.
     */
    name: string;
    /**
     * Notification
     * @description Represents a notification entity.
     */
    notification: {
      readonly id: components["schemas"]["notification_id"];
      readonly type: components["schemas"]["event_type_name"];
      readonly status: components["schemas"]["status-notification"];
      readonly payload: components["schemas"]["event"] & {
        notification_id?: components["schemas"]["notification_id"];
      };
      /** @description RFC 3339 datetime string of when this notification occurred. */
      readonly occurred_at: components["schemas"]["timestamp"];
      /** @description RFC 3339 datetime string of when this notification was delivered. `null` if not yet delivered successfully. */
      readonly delivered_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this notification was replayed. `null` if not replayed. */
      readonly replayed_at: components["schemas"]["timestamp"] | null;
      /**
       * NotificationOrigin
       * @description Describes how this notification was created.
       * @enum {string}
       */
      readonly origin: "event" | "replay";
      /** @description RFC 3339 datetime string of when this notification was last attempted. */
      readonly last_attempt_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this notification is scheduled to be retried. */
      readonly retry_at: components["schemas"]["timestamp"] | null;
      /** @description How many times delivery of this notification has been attempted. Automatically incremented by Paddle after an attempt. */
      readonly times_attempted: number;
      readonly notification_setting_id: components["schemas"]["notification_setting_id"];
    };
    /**
     * Notification ID
     * @description Unique Paddle ID for this notification, prefixed with `ntf_`.
     */
    notification_id: string;
    /**
     * NotificationLog
     * @description Represents a notification log entity.
     */
    notification_log: {
      readonly id: components["schemas"]["notification_log_id"];
      /** @description HTTP code sent by the responding server. */
      readonly response_code: number;
      /** @description Content-Type sent by the responding server. */
      readonly response_content_type: string | null;
      /** @description Response body sent by the responding server. Typically empty for success responses. */
      readonly response_body: string;
      /** @description RFC 3339 datetime string of when Paddle attempted to deliver the related notification. */
      readonly attempted_at: components["schemas"]["timestamp"];
    };
    /**
     * Notification log ID
     * @description Unique Paddle ID for this notification log, prefixed with `ntflog_`.
     */
    notification_log_id: string;
    /**
     * NotificationSetting
     * @description Represents a notification destination.
     */
    notification_setting: {
      readonly id: components["schemas"]["notification_setting_id"];
      /** @description Short description for this notification destination. Shown in the Paddle dashboard. */
      description: string;
      /**
       * NotificationSettingType
       * @description Where notifications should be sent for this destination.
       * @enum {string}
       */
      type: "email" | "url";
      /** @description Webhook endpoint URL or email address. */
      destination: string;
      /**
       * @description Whether Paddle should try to deliver events to this notification destination.
       * @default true
       */
      active: boolean;
      /** @description API version that returned objects for events should conform to. Must be a valid version of the Paddle API. Can't be a version older than your account default. */
      api_version: number;
      /**
       * @description Whether potentially sensitive fields should be sent to this notification destination.
       * @default false
       */
      include_sensitive_fields: boolean;
      /** @description Subscribed events for this notification destination. */
      subscribed_events: components["schemas"]["event_type"][];
      /** @description Webhook destination secret key, prefixed with `pdl_ntfset_`. Used for signature verification. */
      readonly endpoint_secret_key: string;
      /**
       * @description Whether Paddle should deliver real platform events, simulation events or both to this notification destination.
       * @enum {string}
       */
      traffic_source: "platform" | "simulation" | "all";
    };
    /**
     * NotificationSettingCreate
     * @description Represents a notification destination when creating notification destinations.
     */
    "notification_setting-create": {
      readonly id?: components["schemas"]["notification_setting_id"];
      /** @description Short description for this notification destination. Shown in the Paddle Dashboard. */
      description: string;
      /**
       * NotificationSettingType
       * @description Where notifications should be sent for this destination.
       * @enum {string}
       */
      type: "email" | "url";
      /** @description Webhook endpoint URL or email address. */
      destination: string;
      /**
       * @description Whether Paddle should try to deliver events to this notification destination.
       * @default true
       */
      readonly active?: boolean;
      /** @description API version that returned objects for events should conform to. Must be a valid version of the Paddle API. Can't be a version older than your account default. If omitted, defaults to your account default version. */
      api_version?: number;
      /**
       * @description Whether potentially sensitive fields should be sent to this notification destination. If omitted, defaults to `false`.
       * @default false
       */
      include_sensitive_fields?: boolean;
      /** @description Subscribed events for this notification destination. When creating or updating a notification destination, pass an array of event type names only. Paddle returns the complete event type object. */
      subscribed_events: components["schemas"]["event_type_name"][];
      /** @description Webhook destination secret key, prefixed with `pdl_ntfset_`. Used for signature verification. */
      readonly endpoint_secret_key?: string;
      /**
       * @description Whether Paddle should deliver real platform events, simulation events or both to this notification destination. If omitted, defaults to `platform`.
       * @default platform
       * @enum {string}
       */
      traffic_source?: "platform" | "simulation" | "all";
    };
    /**
     * NotificationSettingUpdate
     * @description Represents a notification destination when updating notification destinations.
     */
    "notification_setting-update": {
      /** @description Short description for this notification destination. Shown in the Paddle Dashboard. */
      description: string;
      /** @description Webhook endpoint URL or email address. */
      destination: string;
      /**
       * @description Whether Paddle should try to deliver events to this notification destination.
       * @default true
       */
      active: boolean;
      /** @description API version that returned objects for events should conform to. Must be a valid version of the Paddle API. Can't be a version older than your account default. Defaults to your account default if omitted. */
      api_version: number;
      /**
       * @description Whether potentially sensitive fields should be sent to this notification destination.
       * @default false
       */
      include_sensitive_fields: boolean;
      /** @description Subscribed events for this notification destination. When creating or updating a notification destination, pass an array of event type names only. Paddle returns the complete event type object. */
      subscribed_events: components["schemas"]["event_type_name"][];
      /**
       * @description Whether Paddle should deliver real platform events, simulation events or both to this notification destination.
       * @enum {string}
       */
      traffic_source: "platform" | "simulation" | "all";
    };
    /**
     * Notification setting ID
     * @description Unique Paddle ID for this notification setting, prefixed with `ntfset_`.
     */
    notification_setting_id: string;
    /**
     * FilterOperator
     * @description Operator to use when filtering.
     * @enum {string}
     */
    operator: "lt" | "gte" | null;
    /**
     * Transaction origin
     * @description Describes how this transaction was created.
     */
    "origin-transaction":
      | "api"
      | "subscription_charge"
      | "subscription_payment_method_change"
      | "subscription_recurring"
      | "subscription_update"
      | "web";
    /**
     * PaddleID
     * @description Unique Paddle ID for this entity.
     */
    paddle_id: string;
    /**
     * Pagination
     * @description Keys used for working with paginated results.
     */
    pagination: {
      /** @description Number of entities per page for this response. May differ from the number requested if the requested number is greater than the maximum. */
      readonly per_page: number;
      /**
       * Format: uri
       * @description URL containing the query parameters of the original request, along with the `after` parameter that marks the starting point of the next page. Always returned, even if `has_more` is `false`.
       */
      readonly next: string;
      /** @description Whether this response has another page. */
      readonly has_more: boolean;
      /** @description Estimated number of entities for this response. */
      readonly estimated_total?: number;
    };
    /**
     * payment_method.deleted
     * @description Occurs when a payment method is deleted.
     */
    "payment_method.deleted": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Payment Method Deleted Notification */
      data?: {
        id: components["schemas"]["payment_method_id"];
        /** @description Paddle ID of the customer that this payment method is saved for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address for this payment method, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /**
         * PaymentMethodDeletionReason
         * @description Reason why this payment method was deleted.
         * @enum {string}
         */
        deletion_reason: "replaced_by_newer_version" | "api";
        /**
         * SavedPaymentMethodType
         * @description Type of payment method saved.
         * @enum {string}
         */
        type: "alipay" | "apple_pay" | "card" | "google_pay" | "korea_local" | "paypal";
        /**
         * PaymentMethodOrigin
         * @description Describes how this payment method was saved.
         * @enum {string}
         */
        origin: "saved_during_purchase" | "subscription";
        saved_at: components["schemas"]["saved_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * payment_method.saved
     * @description Occurs when a payment method is saved.
     */
    "payment_method.saved": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Payment Method Saved Notification */
      data?: {
        id: components["schemas"]["payment_method_id"];
        /** @description Paddle ID of the customer that this payment method is saved for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address for this payment method, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /**
         * SavedPaymentMethodType
         * @description Type of payment method saved.
         * @enum {string}
         */
        type: "alipay" | "apple_pay" | "card" | "google_pay" | "korea_local" | "paypal";
        /**
         * @description Describes how this payment method was saved.
         * @enum {string}
         */
        origin: "saved_during_purchase" | "subscription";
        saved_at: components["schemas"]["saved_at"];
        updated_at: components["schemas"]["updated_at"];
      };
    };
    /**
     * Payment Method ID
     * @description Unique Paddle ID for this payment method entity, prefixed with `paymtd_`.
     */
    payment_method_id: string;
    /**
     * payment_method_type
     * @description Type of payment method available for use in the checkout.
     * @enum {string}
     */
    payment_method_type:
      | "alipay"
      | "apple_pay"
      | "bancontact"
      | "card"
      | "google_pay"
      | "ideal"
      | "korea_local"
      | "paypal";
    /**
     * payout.created
     * @description Occurs when a payout is initiated by Paddle.
     */
    "payout.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Payout Notification */
      data?: {
        /** @description ID for this payout. */
        id: string;
        /**
         * @description Status of this payout.
         * @enum {string}
         */
        status: "unpaid" | "paid";
        /** @description Amount paid, or scheduled to be paid, for this payout. */
        amount: string;
        /** @description Three-letter ISO 4217 currency code for this payout. */
        currency_code: components["schemas"]["currency_code-payout"];
      };
    };
    /**
     * payout.paid
     * @description Occurs when a payout is paid. This is usually the working day before the funds credit your account.
     */
    "payout.paid": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Payout Notification */
      data?: {
        /** @description ID for this payout. */
        id: string;
        /**
         * @description Status of this payout.
         * @enum {string}
         */
        status: "unpaid" | "paid";
        /** @description Amount paid, or scheduled to be paid, for this payout. */
        amount: string;
        /** @description Three-letter ISO 4217 currency code for this payout. */
        currency_code: components["schemas"]["currency_code-payout"];
      };
    };
    /**
     * PayPal
     * @description PayPal metadata
     */
    paypal: {
      /**
       * @description Email address associated with the PayPal account.
       * @example john.doe@example.com
       */
      email: string;
      /** @description PayPal payment method identifier. */
      reference: string;
    };
    /** @enum {string} */
    permission:
      | "address.read"
      | "address.write"
      | "adjustment.read"
      | "adjustment.write"
      | "business.read"
      | "business.write"
      | "customer.read"
      | "customer.write"
      | "customer_auth_token.write"
      | "customer_portal_session.write"
      | "discount.read"
      | "discount.write"
      | "notification.read"
      | "notification.write"
      | "notification_setting.read"
      | "notification_setting.write"
      | "notification_simulation.read"
      | "notification_simulation.write"
      | "payment_method.read"
      | "payment_method.write"
      | "price.read"
      | "price.write"
      | "product.read"
      | "product.write"
      | "report.read"
      | "report.write"
      | "subscription.read"
      | "subscription.write"
      | "transaction.read"
      | "transaction.write";
    /**
     * Price
     * @description Represents a price entity.
     */
    price: {
      readonly id: components["schemas"]["price_id"];
      /** @description Paddle ID for the product that this price is for, prefixed with `pro_`. */
      product_id: components["schemas"]["product_id"];
      /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
      description: string;
      type: components["schemas"]["catalog-type"];
      name: components["schemas"]["price_name"];
      /** @description How often this price should be charged. `null` if price is non-recurring (one-time). */
      billing_cycle: components["schemas"]["duration"] | null;
      /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over. `null` for no trial period. Requires `billing_cycle`. */
      trial_period: components["schemas"]["price_trial_duration"] | null;
      tax_mode: components["schemas"]["tax_mode"];
      /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
      unit_price: components["schemas"]["money"];
      /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
      unit_price_overrides: components["schemas"]["unit_price_override"][];
      /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. */
      quantity: components["schemas"]["price_quantity"];
      /** @default active */
      status: components["schemas"]["status"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
    };
    /**
     * PriceCreate
     * @description Represents a price entity when creating prices.
     */
    "price-create": {
      readonly id?: components["schemas"]["price_id"];
      /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
      description: string;
      /** @description Type of item. Standard items are considered part of your catalog and are shown in the Paddle dashboard. If omitted, defaults to `standard`. */
      type?: components["schemas"]["catalog-type"];
      name?: components["schemas"]["price_name"];
      /** @description Paddle ID for the product that this price is for, prefixed with `pro_`. */
      product_id: components["schemas"]["product_id"];
      /** @description How often this price should be charged. `null` if price is non-recurring (one-time). If omitted, defaults to `null`. */
      billing_cycle?: components["schemas"]["duration"] | null;
      /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over.
       *     `null` for no trial period. Requires `billing_cycle`. If omitted, defaults to `null`. */
      trial_period?: components["schemas"]["price_trial_duration"] | null;
      /** @description How tax is calculated for this price. If omitted, defaults to `account_setting`. */
      tax_mode?: components["schemas"]["tax_mode"];
      /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
      unit_price: components["schemas"]["money"];
      /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
      unit_price_overrides?: components["schemas"]["unit_price_override"][];
      /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. If omitted, defaults to 1-100. */
      quantity?: components["schemas"]["price_quantity"];
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta?: components["schemas"]["import_meta"] | null;
    };
    /**
     * PriceIncludes
     * @description Represents a price entity with included entities.
     */
    "price-includes": components["schemas"]["price"] & {
      /** @description Related product for this price. Returned when the `include` parameter is used with the `product` value. */
      product?: components["schemas"]["product"];
    };
    /**
     * Price preview
     * @description Represents a price preview entity.
     */
    "price-preview": {
      /** @description Unique Paddle ID for this price, prefixed with `pri_`.
       *     The value is null for custom prices being previewed. */
      readonly id: components["schemas"]["price_id"] | null;
      /** @description Paddle ID for the product that this price is for, prefixed with `pro_`.
       *     The value is null for custom products being previewed. */
      product_id: components["schemas"]["product_id"] | null;
      /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
      description: string;
      type: components["schemas"]["catalog-type"];
      name: components["schemas"]["price_name"];
      /** @description How often this price should be charged. `null` if price is non-recurring (one-time). */
      billing_cycle: components["schemas"]["duration"] | null;
      /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over. `null` for no trial period. Requires `billing_cycle`. */
      trial_period: components["schemas"]["duration"] | null;
      tax_mode: components["schemas"]["tax_mode"];
      /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
      unit_price: components["schemas"]["money"];
      /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
      unit_price_overrides: components["schemas"]["unit_price_override"][];
      /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. */
      quantity: components["schemas"]["price_quantity"];
      /** @default active */
      status: components["schemas"]["status"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
    };
    /**
     * PriceUpdate
     * @description Represents a price entity when updating prices.
     */
    "price-update": {
      /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
      description: string;
      type: components["schemas"]["catalog-type"];
      name: components["schemas"]["price_name"];
      /** @description How often this price should be charged. `null` if price is non-recurring (one-time). */
      billing_cycle: components["schemas"]["duration"] | null;
      /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over. `null` for no trial period. Requires `billing_cycle`. */
      trial_period: components["schemas"]["duration"] | null;
      tax_mode: components["schemas"]["tax_mode"];
      /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
      unit_price: components["schemas"]["money"];
      /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
      unit_price_overrides: components["schemas"]["unit_price_override"][];
      /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. */
      quantity: components["schemas"]["price_quantity"];
      status: components["schemas"]["status"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
    };
    /**
     * price.created
     * @description Occurs when a price is created.
     *
     *     `created_at` and `updated_at` may be `null` in events that occurred before this field was added to price entities.
     */
    "price.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Price Notification
       * @description Represents a price entity.
       */
      data?: {
        readonly id: components["schemas"]["price_id"];
        /** @description Paddle ID for the product that this price is for, prefixed with `pro_`. */
        product_id: components["schemas"]["product_id"];
        /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
        description: string;
        type: components["schemas"]["catalog-type"] | null;
        /** @description Name of this price, shown to customers at checkout and on invoices. Typically describes how often the related product bills. */
        name: string | null;
        /** @description How often this price should be charged. `null` if price is non-recurring (one-time). */
        billing_cycle: components["schemas"]["duration"] | null;
        /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over. `null` for no trial period. Requires `billing_cycle`. */
        trial_period: components["schemas"]["duration"] | null;
        tax_mode: components["schemas"]["tax_mode"];
        /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
        unit_price: components["schemas"]["money"];
        /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
        unit_price_overrides: components["schemas"]["unit_price_override"][];
        /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. */
        quantity: components["schemas"]["price_quantity"];
        status: components["schemas"]["status"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
        /** @description RFC 3339 datetime string of when this entity was created. Set automatically by Paddle. */
        readonly created_at: components["schemas"]["created_at"] | null;
        /** @description RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle. */
        readonly updated_at: components["schemas"]["updated_at"] | null;
      };
    };
    /**
     * price.imported
     * @description Occurs when a price is imported.
     *
     *     `created_at` and `updated_at` may be `null` in events that occurred before this field was added to price entities.
     */
    "price.imported": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Price Notification
       * @description Represents a price entity.
       */
      data?: {
        readonly id: components["schemas"]["price_id"];
        /** @description Paddle ID for the product that this price is for, prefixed with `pro_`. */
        product_id: components["schemas"]["product_id"];
        /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
        description: string;
        type: components["schemas"]["catalog-type"] | null;
        /** @description Name of this price, shown to customers at checkout and on invoices. Typically describes how often the related product bills. */
        name: string | null;
        /** @description How often this price should be charged. `null` if price is non-recurring (one-time). */
        billing_cycle: components["schemas"]["duration"] | null;
        /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over. `null` for no trial period. Requires `billing_cycle`. */
        trial_period: components["schemas"]["duration"] | null;
        tax_mode: components["schemas"]["tax_mode"];
        /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
        unit_price: components["schemas"]["money"];
        /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
        unit_price_overrides: components["schemas"]["unit_price_override"][];
        /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. */
        quantity: components["schemas"]["price_quantity"];
        status: components["schemas"]["status"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
        /** @description RFC 3339 datetime string of when this entity was created. Set automatically by Paddle. */
        readonly created_at: components["schemas"]["created_at"] | null;
        /** @description RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle. */
        readonly updated_at: components["schemas"]["updated_at"] | null;
      };
    };
    /**
     * price.updated
     * @description Occurs when a price is updated.
     *
     *     `created_at` and `updated_at` may be `null` in events that occurred before this field was added to price entities.
     */
    "price.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Price Notification
       * @description Represents a price entity.
       */
      data?: {
        readonly id: components["schemas"]["price_id"];
        /** @description Paddle ID for the product that this price is for, prefixed with `pro_`. */
        product_id: components["schemas"]["product_id"];
        /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
        description: string;
        type: components["schemas"]["catalog-type"] | null;
        /** @description Name of this price, shown to customers at checkout and on invoices. Typically describes how often the related product bills. */
        name: string | null;
        /** @description How often this price should be charged. `null` if price is non-recurring (one-time). */
        billing_cycle: components["schemas"]["duration"] | null;
        /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over. `null` for no trial period. Requires `billing_cycle`. */
        trial_period: components["schemas"]["duration"] | null;
        tax_mode: components["schemas"]["tax_mode"];
        /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
        unit_price: components["schemas"]["money"];
        /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
        unit_price_overrides: components["schemas"]["unit_price_override"][];
        /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. */
        quantity: components["schemas"]["price_quantity"];
        status: components["schemas"]["status"];
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
        /** @description RFC 3339 datetime string of when this entity was created. Set automatically by Paddle. */
        readonly created_at: components["schemas"]["created_at"] | null;
        /** @description RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle. */
        readonly updated_at: components["schemas"]["updated_at"] | null;
      };
    };
    /**
     * Price ID
     * @description Unique Paddle ID for this price, prefixed with `pri_`.
     */
    price_id: string;
    /**
     * Price Name
     * @description Name of this price, shown to customers at checkout and on invoices. Typically describes how often the related product bills.
     */
    price_name: string | null;
    /** price_quantity */
    price_quantity: {
      /**
       * @description Minimum quantity of the product related to this price that can be bought. Required if `maximum` set.
       * @default 1
       */
      minimum: number;
      /**
       * @description Maximum quantity of the product related to this price that can be bought. Required if `minimum` set. Must be greater than or equal to the `minimum` value.
       * @default 100
       */
      maximum: number;
    };
    /** Price Trial Duration */
    price_trial_duration: {
      /**
       * @description Unit of time.
       * @enum {string}
       */
      interval: "day" | "week" | "month" | "year";
      /** @description Amount of time. */
      frequency: number;
    };
    /**
     * Product
     * @description Represents a product entity.
     */
    product: {
      readonly id: components["schemas"]["product_id"];
      name: components["schemas"]["product_name"];
      /** @description Short description for this product. */
      description: string | null;
      type: components["schemas"]["catalog-type"];
      tax_category: components["schemas"]["tax_category"];
      /** @description Image for this product. Included in the checkout and on some customer documents. */
      image_url: components["schemas"]["image_url"] | null | components["schemas"]["empty_string"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @default active */
      status: components["schemas"]["status"];
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
    };
    /**
     * ProductCreate
     * @description Represents a product entity when creating products.
     */
    "product-create": {
      readonly id?: components["schemas"]["product_id"];
      /** @description Name of this product. */
      name: string;
      /** @description Short description for this product. */
      description?: string | null;
      /** @description Type of item. Standard items are considered part of your catalog and are shown in the Paddle dashboard. If omitted, defaults to `standard`. */
      type?: components["schemas"]["catalog-type"];
      tax_category: components["schemas"]["tax_category"];
      /** @description Image for this product. Included in the checkout and on some customer documents. */
      image_url?: string | null;
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta?: components["schemas"]["import_meta"] | null;
    };
    /**
     * Product with includes
     * @description Represents a product entity with included entities.
     */
    "product-includes": components["schemas"]["product"] & {
      /** @description Prices for this product. Returned when the `include` parameter is used with the `prices` value. */
      prices?: components["schemas"]["price"][];
    };
    /**
     * Product preview
     * @description Represents a product (preview) entity.
     */
    "product-preview": {
      /** @description Unique Paddle ID for this product, prefixed with `pro_`.
       *     The value is null for custom products being previewed. */
      readonly id: components["schemas"]["product_id"] | null;
      name: components["schemas"]["product_name"];
      /** @description Short description for this product. */
      description: string | null;
      type: components["schemas"]["catalog-type"];
      tax_category: components["schemas"]["tax_category"];
      /** @description Image for this product. Included in the checkout and on some customer documents. */
      image_url: components["schemas"]["image_url"] | null | components["schemas"]["empty_string"];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @default active */
      status: components["schemas"]["status"];
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta"] | null;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
    };
    /**
     * ProductUpdate
     * @description Represents a product entity when updating products.
     */
    "product-update": {
      /** @description Name of this product. */
      name: string;
      /** @description Short description for this product. */
      description: string | null;
      type: components["schemas"]["catalog-type"];
      tax_category: components["schemas"]["tax_category"];
      /** @description Image for this product. Included in the checkout and on some customer documents. */
      image_url: null | string;
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      status: components["schemas"]["status"];
    };
    /**
     * product.created
     * @description Occurs when a product is created.
     *
     *     `updated_at` may be `null` in events that occurred before this field was added to product entities.
     */
    "product.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Product Notification
       * @description Represents a product entity.
       */
      data?: {
        readonly id: components["schemas"]["product_id"];
        /** @description Name of this product. */
        name: string;
        /** @description Short description for this product. */
        description: string | null;
        type: components["schemas"]["catalog-type"] | null;
        tax_category: components["schemas"]["tax_category"];
        /** @description Image for this product. Included in the checkout and on some customer documents. */
        image_url: null | string;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
        readonly created_at: components["schemas"]["created_at"];
        /** @description RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle. */
        readonly updated_at: components["schemas"]["updated_at"] | null;
      };
    };
    /**
     * product.imported
     * @description Occurs when a product is imported.
     *
     *     `updated_at` may be `null` in events that occurred before this field was added to product entities.
     */
    "product.imported": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Product Notification
       * @description Represents a product entity.
       */
      data?: {
        readonly id: components["schemas"]["product_id"];
        /** @description Name of this product. */
        name: string;
        /** @description Short description for this product. */
        description: string | null;
        type: components["schemas"]["catalog-type"] | null;
        tax_category: components["schemas"]["tax_category"];
        /** @description Image for this product. Included in the checkout and on some customer documents. */
        image_url: null | string;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
        readonly created_at: components["schemas"]["created_at"];
        /** @description RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle. */
        readonly updated_at: components["schemas"]["updated_at"] | null;
      };
    };
    /**
     * product.updated
     * @description Occurs when a product is updated.
     *
     *     `updated_at` may be `null` in events that occurred before this field was added to product entities.
     */
    "product.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Product Notification
       * @description Represents a product entity.
       */
      data?: {
        readonly id: components["schemas"]["product_id"];
        /** @description Name of this product. */
        name: string;
        /** @description Short description for this product. */
        description: string | null;
        type: components["schemas"]["catalog-type"] | null;
        tax_category: components["schemas"]["tax_category"];
        /** @description Image for this product. Included in the checkout and on some customer documents. */
        image_url: null | string;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @default active */
        status: components["schemas"]["status"];
        /** @description Import information for this entity. `null` if this entity is not imported. */
        readonly import_meta: components["schemas"]["import_meta"] | null;
        readonly created_at: components["schemas"]["created_at"];
        /** @description RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle. */
        readonly updated_at: components["schemas"]["updated_at"] | null;
      };
    };
    /**
     * Product ID
     * @description Unique Paddle ID for this product, prefixed with `pro_`.
     */
    product_id: string;
    /**
     * Product Name
     * @description Name of this product.
     */
    product_name: string;
    /**
     * Report
     * @description Represents a report entity.
     */
    report:
      | components["schemas"]["report-adjustments"]
      | components["schemas"]["report-transactions"]
      | components["schemas"]["report-products-prices"]
      | components["schemas"]["report-discounts"]
      | components["schemas"]["report-balance"];
    /**
     * ReportAdjustments
     * @description Report entity when working with adjustments reports.
     */
    "report-adjustments": components["schemas"]["report-base"] & {
      /** @description Type of report to create. */
      type: components["schemas"]["report_type_adjustments"];
      /** @description Filter criteria for this report. If omitted, reports are filtered to include data updated in the last 30 days. This means `updated_at` is greater than or equal to (`gte`) the date 30 days ago from the time the report was generated. */
      filters?: components["schemas"]["report_filter_adjustments"];
    };
    /**
     * ReportBalance
     * @description Report entity when working with the balance report.
     */
    "report-balance": components["schemas"]["report-base"] & {
      /**
       * BalanceReportType
       * @description Type of report to create.
       * @enum {string}
       */
      type: "balance";
      /** @description Filter criteria for this report. If omitted, reports are filtered to include data updated in the last 30 days. This means `updated_at` is greater than or equal to (`gte`) the date 30 days ago from the time the report was generated. */
      filters?: components["schemas"]["report_filter_balance"];
    };
    /**
     * ReportBase
     * @description Represents a report entity.
     */
    "report-base": {
      /** @description Unique Paddle ID for this report, prefixed with `rep_` */
      readonly id: components["schemas"]["paddle_id"];
      /** @default pending */
      readonly status: components["schemas"]["status-report"];
      /** @description Number of records in this report. `null` if the report is `pending`. */
      readonly rows: number | null;
      /** @description RFC 3339 datetime string of when this report expires. The report is no longer available to download after this date. */
      readonly expires_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this report was last updated. */
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description RFC 3339 datetime string of when this report was created. */
      readonly created_at: components["schemas"]["created_at"];
    };
    /**
     * ReportDiscounts
     * @description Report entity when working with the discounts report.
     */
    "report-discounts": components["schemas"]["report-base"] & {
      /**
       * DiscountsReportType
       * @description Type of report to create.
       * @enum {string}
       */
      type: "discounts";
      /** @description Filter criteria for this report. If omitted, reports are filtered to include data updated in the last 30 days. This means `updated_at` is greater than or equal to (`gte`) the date 30 days ago from the time the report was generated. */
      filters?: components["schemas"]["report_filter_discounts"];
    };
    /**
     * ReportProductsPrices
     * @description Report entity when working with the products and prices report.
     */
    "report-products-prices": components["schemas"]["report-base"] & {
      /**
       * ProductsPricesReportType
       * @description Type of report to create.
       * @enum {string}
       */
      type: "products_prices";
      /** @description Filter criteria for this report. If omitted, reports are filtered to include data updated in the last 30 days. This means `product_updated_at` and `price_updated_at` are greater than or equal to (`gte`) the date 30 days ago from the time the report was generated. */
      filters?: components["schemas"]["report_filter_products_prices"];
    };
    /**
     * ReportTransactions
     * @description Report entity when working with transactions reports.
     */
    "report-transactions": components["schemas"]["report-base"] & {
      /** @description Type of report to create. */
      type: components["schemas"]["report_type_transactions"];
      /** @description Filter criteria for this report. If omitted, reports are filtered to include data updated in the last 30 days. This means `updated_at` is greater than or equal to (`gte`) the date 30 days ago from the time the report was generated. */
      filters?: components["schemas"]["report_filter_transactions"];
    };
    /**
     * report.created
     * @description Occurs when a report is created.
     */
    "report.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Report Notification
       * @description New or changed entity.
       */
      data?:
        | components["schemas"]["report-adjustments"]
        | components["schemas"]["report-transactions"]
        | components["schemas"]["report-products-prices"]
        | components["schemas"]["report-discounts"];
    };
    /**
     * report.updated
     * @description Occurs when a report is updated.
     */
    "report.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /**
       * Report Notification
       * @description New or changed entity.
       */
      data?:
        | components["schemas"]["report-adjustments"]
        | components["schemas"]["report-transactions"]
        | components["schemas"]["report-products-prices"]
        | components["schemas"]["report-discounts"];
    };
    /**
     * AdjustmentsReportFilters
     * @description List of filters applied to this report.
     */
    report_filter_adjustments: {
      /**
       * AdjustmentsReportFilterName
       * @description Field name to filter by.
       * @enum {string}
       */
      name: "action" | "currency_code" | "status" | "updated_at";
      /** @description Operator to use when filtering. Valid when filtering by `updated_at`, `null` otherwise. */
      operator: components["schemas"]["operator"] | null;
      /** @description Value to filter by. Check the allowed values descriptions for the `name` field to see valid values for a field. */
      value: unknown[] | string;
    }[];
    /**
     * BalanceReportFilters
     * @description List of filters applied to this report.
     */
    report_filter_balance: {
      /**
       * BalanceReportFilterName
       * @description Field name to filter by.
       * @enum {string}
       */
      name: "updated_at";
      /** @description Operator to use when filtering. Valid when filtering by `updated_at`, `null` otherwise. */
      operator: components["schemas"]["operator"] | null;
      /** @description Value to filter by. Check the allowed values descriptions for the `name` field to see valid values for a field. */
      value: unknown[] | string;
    }[];
    /**
     * DiscountsReportFilters
     * @description List of filters applied to this report.
     */
    report_filter_discounts: {
      /**
       * DiscountsReportFilterName
       * @description Field name to filter by.
       * @enum {string}
       */
      name: "type" | "status" | "updated_at";
      /** @description Operator to use when filtering. Valid when filtering by `updated_at`, `null` otherwise. */
      operator: components["schemas"]["operator"] | null;
      /** @description Value to filter by. Check the allowed values descriptions for the `name` field to see valid values for a field. */
      value: unknown[] | string;
    }[];
    /**
     * ProductPricesReportFilters
     * @description List of filters applied to this report.
     */
    report_filter_products_prices: {
      /**
       * ProductPricesReportFilterName
       * @description Field name to filter by.
       * @enum {string}
       */
      name:
        | "product_status"
        | "price_status"
        | "product_type"
        | "price_type"
        | "product_updated_at"
        | "price_updated_at";
      /** @description Operator to use when filtering. Valid when filtering by `updated_at`, `null` otherwise. */
      operator: components["schemas"]["operator"] | null;
      /** @description Value to filter by. */
      value: unknown[] | string;
    }[];
    /**
     * TransactionsReportFilters
     * @description List of filters applied to this report.
     */
    report_filter_transactions: {
      /**
       * TransactionsReportFilterName
       * @description Field name to filter by.
       * @enum {string}
       */
      name: "collection_mode" | "currency_code" | "origin" | "status" | "updated_at";
      /** @description Operator to use when filtering. Valid when filtering by `updated_at`, `null` otherwise. */
      operator: components["schemas"]["operator"] | null;
      /** @description Value to filter by. Check the allowed values descriptions for the `name` field to see valid values for a field. */
      value: unknown[] | string;
    }[];
    /**
     * AdjustmentsReportType
     * @description Type of report.
     * @enum {string}
     */
    report_type_adjustments: "adjustments" | "adjustment_line_items";
    /**
     * TransactionsReportType
     * @description Type of report.
     * @enum {string}
     */
    report_type_transactions: "transactions" | "transaction_line_items";
    /**
     * Request ID
     * @description Unique ID for the request relating to this response. Provide this when contacting Paddle support about a specific request.
     */
    request_id: string;
    /**
     * Saved at
     * Format: date-time
     * @description RFC 3339 datetime string of when this entity was saved. Set automatically by Paddle.
     */
    saved_at: string;
    /**
     * Simulation
     * @description Represents a simulation entity.
     */
    simulation:
      | components["schemas"]["simulation-standard-events"]
      | components["schemas"]["simulation-scenario-events"];
    /**
     * Subscription creation config
     * @description Configuration resources for subscription creation simulations
     */
    "simulation-config-entities-subscription-creation": {
      /** @description Paddle ID of a customer. Adds customer details to webhook payloads. */
      customer_id: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of an address. Adds address details to webhook payloads. Requires `customer_id`. */
      address_id: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of a business. Adds business details to webhook payloads. Requires `customer_id`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Paddle ID of a payment method. Adds payment method details to webhook payloads. Requires `customer_id`. */
      payment_method_id: components["schemas"]["payment_method_id"] | null;
      /** @description Paddle ID of a discount. Adds discount details (including price calculations) to webhook payloads. Requires `items` or `transaction_id` for the discount to be applied. */
      discount_id: components["schemas"]["discount_id"] | null;
      /** @description Paddle ID of a transaction. Bases the subscription on the transaction. */
      transaction_id: components["schemas"]["transaction_id"] | null;
      /** @description Items to include on the simulated subscription. Only existing products and prices can be simulated. Non-catalog items aren't supported. At least one recurring price must be provided. */
      items: components["schemas"]["subscription_item_create_with_price_id"][] | null;
    };
    /**
     * Subscription creation config for items
     * @description Configuration resources for subscription creation simulations with items
     */
    "simulation-config-entities-subscription-creation-items": {
      /** @description Paddle ID of a customer. Adds customer details to webhook payloads. */
      customer_id: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of an address. Adds address details to webhook payloads. Requires `customer_id`. */
      address_id: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of a business. Adds business details to webhook payloads. Requires `customer_id`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Paddle ID of a payment method. Adds payment method details to webhook payloads. Requires `customer_id`. */
      payment_method_id: components["schemas"]["payment_method_id"] | null;
      /** @description Paddle ID of a discount. Adds discount details (including price calculations) to webhook payloads. Requires `items` or `transaction_id` for the discount to be applied. */
      discount_id: components["schemas"]["discount_id"] | null;
      /** @description Items to include on the simulated subscription. Only existing products and prices can be simulated. Non-catalog items aren't supported. At least one recurring price must be provided. */
      items: components["schemas"]["subscription_item_create_with_price_id"][];
      /** @description Paddle ID of an existing transaction. Simulates passing a transaction ID to Paddle.js. */
      transaction_id: null;
    };
    /**
     * Subscription creation config without prices
     * @description Configuration resources for subscription creation simulations
     */
    "simulation-config-entities-subscription-creation-no-prices": {
      /** @description Paddle ID of a customer. Adds customer details to webhook payloads. */
      customer_id: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of an address. Adds address details to webhook payloads. Requires `customer_id`. */
      address_id: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of a business. Adds business details to webhook payloads. Requires `customer_id`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Paddle ID of a payment method. Adds payment method details to webhook payloads. Requires `customer_id`. */
      payment_method_id: components["schemas"]["payment_method_id"] | null;
      /** @description Paddle ID of an existing discount to apply to the simulated subscription. */
      discount_id: components["schemas"]["discount_id"] | null;
      /** @description Items for the simulated subscription. Only existing products and prices can be simulated. Non-catalog items are not supported */
      items: null;
      /** @description Paddle ID of an existing transaction. Simulates passing a transaction ID to Paddle.js. */
      transaction_id: null;
    };
    /**
     * Subscription creation config for transaction
     * @description Configuration resources for subscription creation simulations with existing transaction
     */
    "simulation-config-entities-subscription-creation-transaction": {
      /** @description Paddle ID of a customer. Adds customer details to webhook payloads. */
      customer_id: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of an address. Adds address details to webhook payloads. Requires `customer_id`. */
      address_id: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of a business. Adds business details to webhook payloads. Requires `customer_id`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Paddle ID of a payment method. Adds payment method details to webhook payloads. Requires `customer_id`. */
      payment_method_id: components["schemas"]["payment_method_id"] | null;
      /** @description Paddle ID of a discount. Adds discount details (including price calculations) to webhook payloads. Requires `items` or `transaction_id` for the discount to be applied. */
      discount_id: components["schemas"]["discount_id"] | null;
      /** @description Paddle ID of a transaction. Bases the subscription from this transaction. */
      transaction_id: components["schemas"]["transaction_id"];
      /** @description Items to include on the simulated subscription. Only existing products and prices can be simulated. Non-catalog items aren't supported. At least one recurring price must be provided. */
      items: null;
    };
    /**
     * Payment outcome options
     * @description Options to configure simulations based on the payment outcome.
     */
    "simulation-config-options-payment": {
      /**
       * @description Determines which webhooks are sent based on the outcome of the payment. If omitted, defaults to `success`.
       * @default success
       * @enum {string}
       */
      payment_outcome:
        | "success"
        | "recovered_existing_payment_method"
        | "recovered_updated_payment_method"
        | "failed";
      /**
       * @description Determines which webhooks are sent based on what happens to the subscription when payment recovery attempts are exhausted. Only applies when `payment_outcome` is `failed`. If omitted, defaults to `null`.
       * @default null
       */
      dunning_exhausted_action: ("subscription_paused" | "subscription_canceled") | null;
    };
    /**
     * Failed payment outcome options
     * @description Options for when the payment outcome is failed.
     */
    "simulation-config-options-payment-failed": {
      /**
       * @description Determines which webhooks are sent based on the outcome of the payment. If omitted, defaults to `success`.
       * @enum {string}
       */
      payment_outcome: "failed";
      /**
       * @description Determines which webhooks are sent based on what happens to the subscription when payment recovery attempts are exhausted. If omitted, defaults to `subscription_canceled`.
       * @default subscription_canceled
       * @enum {string}
       */
      dunning_exhausted_action: "subscription_paused" | "subscription_canceled";
    };
    /**
     * Recovered from existing payment method payment outcome options
     * @description Options for when the payment is recovered from an existing payment method.
     */
    "simulation-config-options-payment-recovered-existing": {
      /**
       * @description Determines which webhooks are sent based on the outcome of the payment. If omitted, defaults to `success`.
       * @enum {string}
       */
      payment_outcome: "recovered_existing_payment_method";
      /** @description Determines which webhooks are sent based on what happens to the subscription when payment recovery attempts are exhausted. Only applies when `payment_outcome` is `failed`. If omitted, defaults to `null`. */
      dunning_exhausted_action: null;
    };
    /**
     * Recovered from updated payment method payment outcome options
     * @description Options for when the payment is recovered from an updated payment method.
     */
    "simulation-config-options-payment-recovered-updated": {
      /**
       * @description Determines which webhooks are sent based on the outcome of the payment. If omitted, defaults to `success`.
       * @enum {string}
       */
      payment_outcome: "recovered_updated_payment_method";
      /** @description Determines which webhooks are sent based on what happens to the subscription when payment recovery attempts are exhausted. Only applies when `payment_outcome` is `failed`. If omitted, defaults to `null`. */
      dunning_exhausted_action: null;
    };
    /**
     * Successful payment outcome options
     * @description Options for when the payment outcome is successful.
     */
    "simulation-config-options-payment-success": {
      /**
       * @description Determines which webhooks are sent based on the outcome of the payment. If omitted, defaults to `success`.
       * @default success
       * @enum {string}
       */
      payment_outcome: "success";
      /** @description Determines which webhooks are sent based on what happens to the subscription when payment recovery attempts are exhausted. Only applies when `payment_outcome` is `failed`. If omitted, defaults to `null`. */
      dunning_exhausted_action: null;
    };
    /**
     * Subscription canceled config
     * @description Configuration for subscription canceled simulations.
     */
    "simulation-config-subscription-cancellation": {
      /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
      entities: {
        /** @description Paddle ID of a subscription to simulate as canceled. Adds details of that subscription to webhook payloads. */
        subscription_id: components["schemas"]["subscription_id"] | null;
      };
      /** @description Options that determine which webhooks are sent as part of a simulation. */
      options: {
        /**
         * @description Determines which webhooks are sent based on when the subscription is paused or canceled. If omitted, defaults to `immediately`.
         * @default immediately
         * @enum {string}
         */
        effective_from: "next_billing_period" | "immediately";
        /**
         * @description Whether a simulated subscription has a past due transaction (`true`) or not (`false`), which determines whether events occur for canceling past due transactions. If omitted, defaults to `false`.
         * @default false
         */
        has_past_due_transaction: boolean;
      };
    };
    /**
     * Subscription canceled config
     * @description Configuration for subscription canceled simulations.
     */
    "simulation-config-subscription-cancellation-create": {
      subscription_cancellation?: components["schemas"]["simulation-config-subscription-cancellation"];
      readonly subscription_creation?: null;
      readonly subscription_pause?: null;
      readonly subscription_renewal?: null;
      readonly subscription_resume?: null;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      type: "subscription_cancellation";
    };
    /**
     * Subscription creation config
     * @description Configuration for subscription creation simulations.
     */
    "simulation-config-subscription-creation": {
      /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
      entities: components["schemas"]["simulation-config-entities-subscription-creation"];
      /** @description Options that determine which webhooks are sent as part of a simulation. */
      options: components["schemas"]["simulation-config-subscription-creation-options"];
    };
    /**
     * Subscription creation config
     * @description Configuration for subscription creation simulations.
     */
    "simulation-config-subscription-creation-create": {
      /** @description Configuration for subscription creation simulations. */
      subscription_creation?: {
        /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
        entities:
          | components["schemas"]["simulation-config-entities-subscription-creation-no-prices"]
          | components["schemas"]["simulation-config-entities-subscription-creation-items"]
          | components["schemas"]["simulation-config-entities-subscription-creation-transaction"];
        /** @description Options that determine which webhooks are sent as part of a simulation. */
        options: components["schemas"]["simulation-config-subscription-creation-options"];
      };
      readonly subscription_cancellation?: null;
      readonly subscription_pause?: null;
      readonly subscription_renewal?: null;
      readonly subscription_resume?: null;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      type: "subscription_creation";
    };
    /**
     * Subscription creation options
     * @description Options to configure subscription creation simulations.
     */
    "simulation-config-subscription-creation-options": {
      /**
       * @description Determines which webhooks are sent based on whether a new or existing customer subscribes, and how their details are entered if they're an existing customer. If omitted, defaults to `new`.
       * @default new
       * @enum {string}
       */
      customer_simulated_as: "new" | "existing_email_matched" | "existing_details_prefilled";
      /**
       * @description Determines which webhooks are sent based on whether a new, existing, or no business was provided. If omitted, defaults to `not_provided`.
       * @default not_provided
       * @enum {string}
       */
      business_simulated_as: "not_provided" | "new" | "existing_details_prefilled";
      /**
       * @description Determines which webhooks are sent based on whether a discount is used and how it's entered. If omitted, defaults to `none`.
       * @default not_provided
       * @enum {string}
       */
      discount_simulated_as: "not_provided" | "prefilled" | "entered_by_customer";
    };
    /**
     * Subscription paused config
     * @description Configuration for subscription paused simulations.
     */
    "simulation-config-subscription-pause": {
      /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
      entities: {
        /** @description Paddle ID of a subscription to simulate as paused. Adds details of that subscription to webhook payloads. */
        subscription_id: components["schemas"]["subscription_id"] | null;
      };
      /** @description Options that determine which webhooks are sent as part of a simulation. */
      options: {
        /**
         * @description Determines which webhooks are sent based on when the subscription is paused or canceled. If omitted, defaults to `immediately`.
         * @default immediately
         * @enum {string}
         */
        effective_from: "next_billing_period" | "immediately";
        /**
         * @description Whether a simulated subscription has a past due transaction (`true`) or not (`false`), which determines whether events occur for canceling past due transactions. If omitted, defaults to `false`.
         * @default false
         */
        has_past_due_transaction: boolean;
      };
    };
    /**
     * Subscription paused config
     * @description Configuration for subscription paused simulations.
     */
    "simulation-config-subscription-pause-create": {
      subscription_pause?: components["schemas"]["simulation-config-subscription-pause"];
      readonly subscription_cancellation?: null;
      readonly subscription_creation?: null;
      readonly subscription_renewal?: null;
      readonly subscription_resume?: null;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      type: "subscription_pause";
    };
    /**
     * Subscription renewal config
     * @description Configuration for subscription renewed simulations.
     */
    "simulation-config-subscription-renewal": {
      /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
      entities: {
        /** @description Paddle ID of a subscription to simulate as renewed. Adds details of that subscription to webhook payloads. */
        subscription_id: components["schemas"]["subscription_id"] | null;
      };
      /** @description Options that determine which webhooks are sent as part of a simulation. */
      options: components["schemas"]["simulation-config-options-payment"];
    };
    /**
     * Subscription renewal config
     * @description Configuration for subscription renewed simulations.
     */
    "simulation-config-subscription-renewal-create": {
      /** @description Configuration for subscription renewed simulations. */
      subscription_renewal?: {
        /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
        entities: {
          /** @description Paddle ID of a subscription to simulate as renewed. Adds details of that subscription to webhook payloads. */
          subscription_id: components["schemas"]["subscription_id"] | null;
        };
        /** @description Options that determine which webhooks are sent as part of a simulation. */
        options:
          | components["schemas"]["simulation-config-options-payment-success"]
          | components["schemas"]["simulation-config-options-payment-failed"]
          | components["schemas"]["simulation-config-options-payment-recovered-existing"]
          | components["schemas"]["simulation-config-options-payment-recovered-updated"];
      };
      readonly subscription_cancellation?: null;
      readonly subscription_creation?: null;
      readonly subscription_pause?: null;
      readonly subscription_resume?: null;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      type: "subscription_renewal";
    };
    /**
     * Subscription resumed config
     * @description Configuration for subscription resumed simulations.
     */
    "simulation-config-subscription-resume": {
      /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
      entities: {
        /** @description Paddle ID of a subscription to simulate as resumed. Adds details of that subscription to webhook payloads. */
        subscription_id: components["schemas"]["subscription_id"] | null;
      };
      /** @description Options that determine which webhooks are sent as part of a simulation. */
      options: components["schemas"]["simulation-config-options-payment"];
    };
    /**
     * Subscription resumed config
     * @description Configuration for subscription resumed simulations.
     */
    "simulation-config-subscription-resume-create": {
      /** @description Configuration for subscription resumed simulations. */
      subscription_resume?: {
        /** @description Adds details of existing Paddle entities to webhook payloads sent in the simulation. */
        entities: {
          /** @description Paddle ID of a subscription to simulate as resumed. Adds details of that subscription to webhook payloads. */
          subscription_id: components["schemas"]["subscription_id"] | null;
        };
        /** @description Options that determine which webhooks are sent as part of a simulation. */
        options:
          | components["schemas"]["simulation-config-options-payment-success"]
          | components["schemas"]["simulation-config-options-payment-failed"]
          | components["schemas"]["simulation-config-options-payment-recovered-existing"]
          | components["schemas"]["simulation-config-options-payment-recovered-updated"];
      };
      readonly subscription_cancellation?: null;
      readonly subscription_creation?: null;
      readonly subscription_pause?: null;
      readonly subscription_renewal?: null;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      type: "subscription_resume";
    };
    /**
     * SimulationCreate
     * @description Represents a simulation entity when creating.
     */
    "simulation-create":
      | components["schemas"]["simulation-standard-events-create"]
      | components["schemas"]["simulation-scenario-events-create"];
    /**
     * SimulationEvent
     * @description Represents a simulation event.
     */
    "simulation-event": {
      readonly id: components["schemas"]["simulation_event_id"];
      readonly status: components["schemas"]["simulation_event_status"];
      readonly event_type: components["schemas"]["event_type_name"];
      /** @description Simulation payload. Pass a JSON object that matches the schema for an event type to simulate a custom payload. If omitted, Paddle populates with a demo example. */
      readonly payload: Record<string, never>;
      /**
       * SimulationEventRequest
       * @description Information about the request. Sent by Paddle as part of the simulation.
       */
      request: {
        /**
         * SimulationEventRequestBody
         * @description Request body sent by Paddle.
         */
        readonly body: string;
      } | null;
      /**
       * SimulationEventResponse
       * @description Information about the response. Sent by the responding server for the notification setting.
       */
      response: {
        /**
         * SimulationEventResponseBody
         * @description Response body sent by the responding server. May be empty for success responses.
         */
        readonly body: string;
        /**
         * SimulationEventResponseStatus
         * @description HTTP status code sent by the responding server.
         */
        readonly status_code: number;
      } | null;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
    };
    /**
     * SimulationRun
     * @description Represents a simulation run entity.
     */
    "simulation-run":
      | components["schemas"]["simulation-run-single-event"]
      | components["schemas"]["simulation-run-scenario"];
    /**
     * SimulationRunIncludes
     * @description Represents a simulation run entity.
     */
    "simulation-run-includes":
      | components["schemas"]["simulation-run-single-event-includes"]
      | components["schemas"]["simulation-run-scenario-includes"];
    /**
     * SimulationRunScenario
     * @description Represents a simulation run entity for a scenario.
     */
    "simulation-run-scenario": {
      readonly id: components["schemas"]["simulation_run_id"];
      status: components["schemas"]["simulation_run_status"];
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description Scenario for this simulation. Scenario simulations play all events sent for a subscription lifecycle event. */
      type: components["schemas"]["simulation_scenario_events_type"];
    };
    /**
     * SimulationRunScenarioIncludes
     * @description Represents a simulation run entity for a scenario.
     */
    "simulation-run-scenario-includes": components["schemas"]["simulation-run-scenario"] & {
      /**
       * SimulationEvent
       * @description Events associated with this simulation run. Paddle creates a list of events for each simulation runs. Returned when the
       *     `include` parameter is used with the `events` value.
       */
      events?: components["schemas"]["simulation-event"][];
    };
    /**
     * SimulationRunSingleEvent
     * @description Represents a simulation run entity for a single event.
     */
    "simulation-run-single-event": {
      readonly id: components["schemas"]["simulation_run_id"];
      status: components["schemas"]["simulation_run_status"];
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description Single event sent for this simulation, in the format `entity.event_type`. */
      type: components["schemas"]["event_type_name"];
    };
    /**
     * SimulationRunSingleEventIncludes
     * @description Represents a simulation run entity for a single event.
     */
    "simulation-run-single-event-includes": components["schemas"]["simulation-run-single-event"] & {
      /**
       * SimulationEvent
       * @description Events associated with this simulation run. Paddle creates a list of events for each simulation runs. Returned when the
       *     `include` parameter is used with the `events` value.
       */
      events?: components["schemas"]["simulation-event"][];
    };
    /**
     * SimulationScenario
     * @description Represents a simulation entity for a scenario.
     */
    "simulation-scenario-events": {
      id: components["schemas"]["simulation_id"];
      /** @default active */
      status: components["schemas"]["status"];
      /** @description Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`. */
      notification_setting_id: components["schemas"]["notification_setting_id"];
      /** @description Name of this simulation. */
      name: string;
      /** @description Scenario for this simulation. Scenario simulations play all events sent for a subscription lifecycle event. */
      type: components["schemas"]["simulation_scenario_events_type"];
      /** @description Simulation payload. `null` for scenarios. */
      payload: null;
      /** @description Configuration for this scenario simulation. Determines which granular flow is simulated and what entities are used to populate webhook payloads with. */
      config: components["schemas"]["simulation_scenario_config"];
      /** @description RFC 3339 datetime string of when this simulation was last run. `null` until run. Set automatically by Paddle. */
      last_run_at: components["schemas"]["timestamp"] | null;
      created_at: components["schemas"]["created_at"];
      updated_at: components["schemas"]["updated_at"];
    };
    /**
     * SimulationScenarioCreate
     * @description Represents a simulation entity for a scenario when creating.
     */
    "simulation-scenario-events-create": {
      /** @description Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`. */
      notification_setting_id: components["schemas"]["notification_setting_id"];
      /** @description Name of this simulation. */
      name: string;
      /** @description Scenario for this simulation. Scenario simulations play all events sent for a subscription lifecycle event. */
      type: components["schemas"]["simulation_scenario_events_type"];
      /** @description Configuration for this scenario simulation. Use to simulate more granular flows and populate payloads with your own entity data. If omitted, Paddle simulates the default scenario flow and populates payloads with demo examples. */
      config?: components["schemas"]["simulation_scenario_create_config"];
    };
    /**
     * SimulationScenarioUpdate
     * @description Represents a simulation entity for a scenario when updating.
     */
    "simulation-scenario-events-update": {
      /** @description Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`. */
      notification_setting_id: components["schemas"]["notification_setting_id"];
      /** @description Name of this simulation. */
      name: string;
      status: components["schemas"]["status"];
      /** @description Scenario for this simulation. Scenario simulations play all events sent for a subscription lifecycle event. */
      type: components["schemas"]["simulation_scenario_events_type"];
      /** @description Configuration for this scenario simulation. Use to simulate more granular flows and populate payloads with your own entity data. If omitted, Paddle simulates the default scenario flow and populates payloads with demo examples. */
      config: components["schemas"]["simulation_scenario_create_config"];
    };
    /**
     * SimulationEvent
     * @description Represents a simulation entity for a single event.
     */
    "simulation-standard-events": {
      id: components["schemas"]["simulation_id"];
      /** @default active */
      status: components["schemas"]["status"];
      /** @description Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`. */
      notification_setting_id: components["schemas"]["notification_setting_id"];
      /** @description Name of this simulation. */
      name: string;
      /** @description Single event sent for this simulation, in the format `entity.event_type`. */
      type: components["schemas"]["event_type_name"];
      /** @description Simulation payload. */
      payload: Record<string, never> | null;
      /** @description Configuration for scenario simulations. `null` for single events. */
      config: null;
      /** @description RFC 3339 datetime string of when this simulation was last run. `null` until run. Set automatically by Paddle. */
      last_run_at: components["schemas"]["timestamp"] | null;
      created_at: components["schemas"]["created_at"];
      updated_at: components["schemas"]["updated_at"];
    };
    /**
     * SimulationSingleEventCreate
     * @description Represents a simulation entity for a single event when creating.
     */
    "simulation-standard-events-create": {
      /** @description Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`. */
      notification_setting_id: components["schemas"]["notification_setting_id"];
      /** @description Name of this simulation. */
      name: string;
      /** @description Single event sent for this simulation, in the format `entity.event_type`. */
      type: components["schemas"]["event_type_name"];
      /** @description Simulation payload. Pass a JSON object that matches the schema for an event type to simulate a custom payload. If omitted, Paddle populates with a demo example. */
      payload?: Record<string, never> | null;
    };
    /**
     * SimulationSingleEventUpdate
     * @description Represents a simulation entity for a single event when updating.
     */
    "simulation-standard-events-update": {
      /** @description Paddle ID of the notification setting where this simulation is sent, prefixed with `ntfset_`. */
      notification_setting_id: components["schemas"]["notification_setting_id"];
      /** @description Name of this simulation. */
      name: string;
      status: components["schemas"]["status"];
      /** @description Single event sent for this simulation, in the format `entity.event_type`. */
      type: components["schemas"]["event_type_name"];
      /** @description Simulation payload. Pass a JSON object that matches the schema for an event type to simulate a custom payload. Set to `null` to clear and populate with a demo example. */
      payload: Record<string, never> | null;
    };
    /**
     * SimulationUpdate
     * @description Represents a simulation entity when updating.
     */
    "simulation-update":
      | components["schemas"]["simulation-standard-events-update"]
      | components["schemas"]["simulation-scenario-events-update"];
    /**
     * Simulation Event ID
     * @description Unique Paddle ID for this simulation event, prefixed with `ntfsimevt_`.
     */
    simulation_event_id: string;
    /**
     * SimulationEventStatus
     * @description Status of this simulation run log.
     * @enum {string}
     */
    simulation_event_status: "pending" | "success" | "failed" | "aborted";
    /**
     * Simulation ID
     * @description Unique Paddle ID for this simulation, prefixed with `ntfsim_`.
     */
    simulation_id: string;
    /**
     * Simulation Run ID
     * @description Unique Paddle ID for this simulation run, prefixed with `ntfsimrun_`.
     */
    simulation_run_id: string;
    /**
     * SimulationRunStatus
     * @description Status of this simulation run.
     * @enum {string}
     */
    simulation_run_status: "pending" | "completed" | "canceled";
    /**
     * SimulationScenarioConfig
     * @description Configuration for this scenario simulation. Determines which granular flow is simulated and what entities are used to populate webhook payloads with.
     */
    simulation_scenario_config: {
      subscription_cancellation:
        | components["schemas"]["simulation-config-subscription-cancellation"]
        | null;
      subscription_creation:
        | components["schemas"]["simulation-config-subscription-creation"]
        | null;
      subscription_pause: components["schemas"]["simulation-config-subscription-pause"] | null;
      subscription_renewal: components["schemas"]["simulation-config-subscription-renewal"] | null;
      subscription_resume: components["schemas"]["simulation-config-subscription-resume"] | null;
    } | null;
    /**
     * SimulationScenarioCreateConfig
     * @description Configuration for this scenario simulation. Use to simulate more granular flows and populate payloads with your own entity data.
     */
    simulation_scenario_create_config:
      | components["schemas"]["simulation-config-subscription-cancellation-create"]
      | components["schemas"]["simulation-config-subscription-creation-create"]
      | components["schemas"]["simulation-config-subscription-pause-create"]
      | components["schemas"]["simulation-config-subscription-renewal-create"]
      | components["schemas"]["simulation-config-subscription-resume-create"]
      | null;
    /**
     * SimulationScenarioType
     * @description Scenario for a simulation.
     * @enum {string}
     */
    simulation_scenario_events_type:
      | "subscription_creation"
      | "subscription_renewal"
      | "subscription_pause"
      | "subscription_resume"
      | "subscription_cancellation";
    /**
     * Simulation type
     * @description Represents a simulation type.
     */
    simulation_type: {
      /** @description Type of simulation sent by Paddle. Single event simulations are in the format `entity.event_type`; scenario simulations are in `snake_case`. */
      name: string;
      /** @description Descriptive label for this simulation type. Typically gives more context about a scenario. Single event simulations are in the format `entity.event_type`. */
      label: string;
      /** @description Short description of this simulation type. */
      description: string;
      /** @description Group for this simulation type. Typically the entity that this event relates to. */
      group: string;
      /**
       * Simulation kind
       * @description Type of simulation.
       * @enum {string}
       */
      type: "single_event" | "scenario";
      /** @description List of events that will be sent for this simulation type. */
      events: components["schemas"]["event_type_name"][];
    };
    /**
     * Status
     * @description Whether this entity can be used in Paddle.
     * @enum {string}
     */
    status: "active" | "archived";
    /**
     * AdjustmentStatus
     * @description Status of this adjustment. Set automatically by Paddle.
     *
     *     Most refunds for live accounts are created with the status of `pending_approval` until reviewed by Paddle, but some are automatically approved. For sandbox accounts, Paddle automatically approves refunds every ten minutes.
     *
     *     Credit adjustments don't require approval from Paddle, so they're created as `approved`.
     * @enum {string}
     */
    "status-adjustment": "pending_approval" | "approved" | "rejected" | "reversed";
    /**
     * DiscountStatus
     * @description Whether this entity can be used in Paddle.
     * @enum {string}
     */
    "status-discount": "active" | "archived";
    /**
     * notification_status
     * @description Status of this notification.
     * @enum {string}
     */
    "status-notification": "not_attempted" | "needs_retry" | "delivered" | "failed";
    /**
     * PaymentAttemptStatus
     * @description Status of this payment attempt.
     * @enum {string}
     */
    "status-payment_attempt":
      | "authorized"
      | "authorized_flagged"
      | "canceled"
      | "captured"
      | "error"
      | "action_required"
      | "pending_no_action_required"
      | "created"
      | "unknown"
      | "dropped";
    /**
     * ReportStatus
     * @description Status of this report. Set automatically by Paddle.
     *
     *     Reports are created as `pending` initially, then move to `ready` when they're available to download.
     * @enum {string}
     */
    "status-report": "pending" | "ready" | "failed" | "expired";
    /**
     * SubscriptionStatus
     * @description Status of this subscription. Set automatically by Paddle. Use the pause subscription or cancel subscription operations to change.
     * @enum {string}
     */
    "status-subscription": "active" | "canceled" | "past_due" | "paused" | "trialing";
    /**
     * TransactionStatus
     * @description Status of this transaction. You may set a transaction to `billed` or `canceled`, other statuses are set automatically by Paddle. Automatically-collected transactions may return `completed` if payment is captured successfully, or `past_due` if payment failed.
     * @enum {string}
     */
    "status-transaction":
      | "draft"
      | "ready"
      | "billed"
      | "paid"
      | "completed"
      | "canceled"
      | "past_due";
    /**
     * TransactionStatus
     * @description Status of this transaction. You may set a transaction to `billed` or `canceled`, other statuses are set automatically by Paddle. Automatically-collected transactions may return `completed` if payment is captured successfully, or `past_due` if payment failed.
     * @enum {string}
     */
    "status-transaction-create":
      | "draft"
      | "ready"
      | "billed"
      | "paid"
      | "completed"
      | "canceled"
      | "past_due";
    /**
     * Subscription
     * @description Represents a subscription entity.
     */
    subscription: {
      readonly id: components["schemas"]["subscription_id"];
      readonly status: components["schemas"]["status-subscription"];
      /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
      customer_id: components["schemas"]["customer_id"];
      /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
      address_id: components["schemas"]["address_id"];
      /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
      currency_code: components["schemas"]["currency_code"];
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
      readonly started_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
      readonly first_billed_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
      next_billed_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
      readonly paused_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
      readonly canceled_at: components["schemas"]["timestamp"] | null;
      /** @description Details of the discount applied to this subscription. */
      discount: components["schemas"]["discount-subscription"] | null;
      /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
      collection_mode: components["schemas"]["collection_mode"];
      /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
      billing_details: components["schemas"]["billing_details"] | null;
      /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
      readonly current_billing_period: components["schemas"]["time_period"] | null;
      /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
      readonly billing_cycle: components["schemas"]["duration"];
      /** @description Change that's scheduled to be applied to a subscription. Use the pause subscription, cancel subscription, and resume subscription operations to create scheduled changes. `null` if no scheduled changes. */
      scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
      readonly management_urls: components["schemas"]["subscription_management_urls"];
      /** @description List of items on this subscription. Only recurring items are returned. */
      readonly items: components["schemas"]["item-subscription"][];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta_subscription"] | null;
    };
    /**
     * SubscriptionCharge
     * @description Represents a one-time charge for a subscription.
     */
    "subscription-charge": {
      /** @description When one-time charges should be billed. */
      effective_from: components["schemas"]["effective_from"];
      /** @description List of one-time charges to bill for. Only prices where the `billing_cycle` is `null` may be added.
       *
       *     You can charge for items that you've added to your catalog by passing the Paddle ID of an existing price entity, or you can charge for non-catalog items by passing a price object.
       *
       *     Non-catalog items can be for existing products, or you can pass a product object as part of your price to charge for a non-catalog product. */
      items: (
        | components["schemas"]["subscription_item_create_with_price_id"]
        | components["schemas"]["subscription_charge_create_with_price"]
        | components["schemas"]["subscription_charge_create_with_price_and_product"]
      )[];
      on_payment_failure?: components["schemas"]["subscription_on_payment_failure"];
    };
    /**
     * SubscriptionIncludes
     * @description Represents a subscription entity with included entities.
     */
    "subscription-includes": components["schemas"]["subscription"] & {
      /** @description Preview of the next transaction for this subscription. May include prorated charges that aren't yet billed and one-time charges. Returned when the `include` parameter is used with the `next_transaction` value. `null` if the subscription is scheduled to cancel or pause. */
      next_transaction?: components["schemas"]["subscription_next_transaction"] | null;
      /** @description Preview of the recurring transaction for this subscription. This is what the customer can expect to be billed when there are no prorated or one-time charges. Returned when the `include` parameter is used with the `recurring_transaction_details` value. */
      recurring_transaction_details?: components["schemas"]["subscription_recurring_transaction_details"];
    };
    /**
     * SubscriptionPreview
     * @description Represents a subscription preview when previewing a subscription.
     */
    "subscription-preview": {
      readonly status: components["schemas"]["status-subscription"];
      /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
      customer_id: components["schemas"]["customer_id"];
      /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
      address_id: components["schemas"]["address_id"];
      /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
      currency_code: components["schemas"]["currency_code"];
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
      readonly started_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
      readonly first_billed_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
      next_billed_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
      readonly paused_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
      readonly canceled_at: components["schemas"]["timestamp"] | null;
      /** @description Details of the discount applied to this subscription. */
      discount: components["schemas"]["discount-subscription"] | null;
      /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
      collection_mode: components["schemas"]["collection_mode"];
      /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
      billing_details: components["schemas"]["billing_details"] | null;
      /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
      readonly current_billing_period: components["schemas"]["time_period"] | null;
      /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
      readonly billing_cycle: components["schemas"]["duration"];
      /** @description Change that's scheduled to be applied to a subscription. Use the pause subscription, cancel subscription, and resume subscription operations to create scheduled changes. `null` if no scheduled changes. */
      scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
      readonly management_urls: components["schemas"]["subscription_management_urls"];
      /** @description List of items on this subscription. Only recurring items are returned. */
      readonly items: components["schemas"]["item-subscription"][];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description Preview of the immediate transaction created as a result of changes to the subscription. Returns a complete object where `proration_billing_mode` is `prorated_immediately` or `full_immediately`; `null` otherwise. */
      readonly immediate_transaction: components["schemas"]["subscription_next_transaction"] | null;
      /** @description Preview of the next transaction for this subscription. Includes charges created where `proration_billing_mode` is `prorated_next_billing_period` or `full_next_billing_period`, as well as one-time charges. `null` if the subscription is scheduled to cancel or pause. */
      readonly next_transaction: components["schemas"]["subscription_next_transaction"] | null;
      /** @description Preview of the recurring transaction for this subscription. This is what the customer can expect to be billed when there are no prorated or one-time charges. */
      readonly recurring_transaction_details: components["schemas"]["subscription_recurring_transaction_details"];
      readonly update_summary: components["schemas"]["update_summary"] | null;
      /** @description Import information for this entity. `null` if this entity is not imported. */
      readonly import_meta: components["schemas"]["import_meta_subscription"] | null;
    };
    /**
     * SubscriptionUpdate
     * @description Represents a subscription entity when updating subscriptions.
     */
    "subscription-update": {
      /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. Include to change the customer for a subscription. */
      customer_id: components["schemas"]["customer_id"];
      /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. Include to change the address for a subscription. */
      address_id: components["schemas"]["address_id"];
      /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. Include to change the business for a subscription. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Supported three-letter ISO 4217 currency code. Include to change the currency that a subscription bills in. When changing `collection_mode` to `manual`, you may need to change currency code to `USD`, `EUR`, or `GBP`. */
      currency_code: components["schemas"]["currency_code"];
      /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. Include to change the next billing date. */
      next_billed_at: components["schemas"]["timestamp"];
      /**
       * SubscriptionDiscountEffectiveFrom
       * @description Details of the discount applied to this subscription. Include to add a discount to a subscription. `null` to remove a discount.
       */
      discount: {
        id: components["schemas"]["discount_id"];
        /** @description When this discount should take effect from. */
        effective_from: components["schemas"]["effective_from"];
      } | null;
      /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
      collection_mode: components["schemas"]["collection_mode"];
      /** @description Details for invoicing. Required if `collection_mode` is `manual`. `null` if changing `collection_mode` to `automatic`. */
      billing_details: components["schemas"]["billing_details_update"] | null;
      /** @description Change that's scheduled to be applied to a subscription. When updating, you may only set to `null` to remove a scheduled change. Use the pause subscription, cancel subscription, and resume subscription operations to create scheduled changes. */
      scheduled_change: null;
      /** @description List of items on this subscription. Only recurring items may be added. Send the complete list of items that should be on this subscription, including existing items to retain. */
      items: (
        | components["schemas"]["subscription_update_item"]
        | components["schemas"]["subscription_item_create_with_price"]
        | components["schemas"]["subscription_item_create_with_price_and_product"]
      )[];
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      proration_billing_mode: components["schemas"]["subscription_update_proration_billing_mode"];
      on_payment_failure: components["schemas"]["subscription_on_payment_failure"];
    };
    /**
     * subscription.activated
     * @description Occurs when a subscription becomes active. Its `status` field changes to `active`.
     *
     *     This means any trial period has elapsed and Paddle has successfully billed the customer.
     *
     *     Payload includes the complete subscription entity, except `management_urls` .Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.activated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.canceled
     * @description Occurs when a subscription is canceled. Its `status` field changes to `canceled`.
     *
     *     If you choose to cancel a subscription immediately, the subscription status changes to `canceled` and `subscription.canceled` occurs.
     *
     *     If you choose to cancel a subscription on the next billing period, Paddle creates a scheduled change to say the subscription should be canceled on the next billing date. [`subscription.updated`](/webhooks/subscriptions/subscription-updated) occurs at this point. On the next billing date, the subscription status changes to `canceled` and `subscription.canceled` occurs.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.canceled": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.created
     * @description Occurs when a subscription is created. Paddle automatically creates subscriptions for recurring items when automatically-collected transactions are `completed`, or when manually-collected transactions are `billed`.
     *
     *     [`subscription.trialing`](/webhooks/subscriptions/subscription-trialing) or [`subscription.activated`](/webhooks/subscriptions/subscription-activated) typically follow.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     *
     *     It also includes a `transaction_id` field, which contains the Paddle ID of the completed or billed transaction that caused Paddle to create this subscription. You can use this to match the created subscription with related transaction events [as part of provisioning](/build/subscriptions/provision-access-webhooks). Other subscription events don't include this field, and it is not returned by the API when working with subscription entities.
     */
    "subscription.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Created Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        /** @description Paddle ID for the transaction entity that resulted in this subscription being created, prefixed with `txn_`. */
        transaction_id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.imported
     * @description Occurs when a subscription is imported.
     *
     *     [`subscription.trialing`](/webhooks/subscriptions/subscription-trialing) or [`subscription.activated`](/webhooks/subscriptions/subscription-activated) typically follow.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.imported": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.past_due
     * @description Occurs when a subscription has an unpaid transaction. Its `status` changes to `past_due`.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.past_due": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.paused
     * @description Occurs when a subscription is paused. Its `status` field changes to `paused`.
     *
     *     If you choose to pause a subscription immediately, the subscription status changes to `paused` and `subscription.paused` occurs.
     *
     *     If you choose to pause a subscription on the next billing period, Paddle creates a scheduled change to say the subscription should be paused on the next billing date. [`subscription.updated`](/webhooks/subscriptions/subscription-updated) occurs at this point. On the next billing date, the subscription status changes to `paused` and `subscription.paused` occurs.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.paused": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.resumed
     * @description Occurs when a subscription is resumed after being paused. Its status field changes to `active`.
     *
     *     When resumed, Paddle bills for the subscription immediately. [`transaction.created`](/webhooks/transactions/transaction-created) and other transaction events occur, depending on the collection mode.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.resumed": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.trialing
     * @description Occurs when a subscription enters trial period.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.trialing": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /**
     * subscription.updated
     * @description Occurs when a subscription is updated.
     *
     *     Payload includes the complete subscription entity, except `management_urls`. Subscription management links are temporary, so they're not included. [Get a subscription using the API](/api-reference/subscriptions/get-subscription) to get management links for a subscription.
     */
    "subscription.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Subscription Notification */
      data?: {
        id: components["schemas"]["subscription_id"];
        status: components["schemas"]["status-subscription"];
        /** @description Paddle ID of the customer that this subscription is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"];
        /** @description Paddle ID of the address that this subscription is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"];
        /** @description Paddle ID of the business that this subscription is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Transactions for this subscription are created in this currency. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        created_at: components["schemas"]["created_at"];
        updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this subscription started. This may be different from `first_billed_at` if the subscription started in trial. */
        readonly started_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was first billed. This may be different from `started_at` if the subscription started in trial. */
        readonly first_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription is next scheduled to be billed. */
        next_billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was paused. Set automatically by Paddle when the pause subscription operation is used. `null` if not paused. */
        readonly paused_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when this subscription was canceled. Set automatically by Paddle when the cancel subscription operation is used. `null` if not canceled. */
        readonly canceled_at: components["schemas"]["timestamp"] | null;
        discount: components["schemas"]["discount-subscription"] | null;
        /** @description How payment is collected for transactions created for this subscription. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Current billing period for this subscription. Set automatically by Paddle based on the billing cycle. `null` for `paused` and `canceled` subscriptions. */
        readonly current_billing_period: components["schemas"]["time_period"] | null;
        /** @description How often this subscription renews. Set automatically by Paddle based on the prices on this subscription. */
        readonly billing_cycle: components["schemas"]["duration"];
        scheduled_change: components["schemas"]["subscription_scheduled_change"] | null;
        /** @description List of items on this subscription. Only recurring items are returned. */
        readonly items: components["schemas"]["item-subscription"][];
        custom_data: components["schemas"]["custom_data"] | null;
        import_meta: components["schemas"]["import_meta"] | null;
      };
    };
    /** Subscription charge create with price */
    subscription_charge_create_with_price: {
      /** @description Quantity to bill for. */
      quantity: number;
      /**
       * SubscriptionChargeCreateWithPrice
       * @description Price object for a non-catalog item to bill for. Include a `product_id` to relate this non-catalog price to an existing catalog price.
       */
      price: {
        /** @description Paddle ID for the product that this price is for, prefixed with `pro_`. */
        product_id: components["schemas"]["product_id"];
        /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
        description: string;
        /** @description Name of this price, shown to customers at checkout and on invoices. Typically describes how often the related product bills. */
        name?: string | null;
        tax_mode?: components["schemas"]["tax_mode"];
        /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
        unit_price: components["schemas"]["money"];
        /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
        unit_price_overrides?: components["schemas"]["unit_price_override"][];
        /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. If omitted, defaults to 1-100. */
        quantity?: components["schemas"]["price_quantity"];
        /** @description Your own structured key-value data. */
        custom_data?: components["schemas"]["custom_data"] | null;
      };
    };
    /** Subscription charge create with price */
    subscription_charge_create_with_price_and_product: {
      /** @description Quantity to bill for. */
      quantity: number;
      /**
       * SubscriptionChargeCreateWithProduct
       * @description Price object for a non-catalog item to charge for. Include a `product` object to create a non-catalog product for this non-catalog price.
       */
      price: {
        /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
        description: string;
        /** @description Name of this price, shown to customers at checkout and on invoices. Typically describes how often the related product bills. */
        name?: string | null;
        tax_mode?: components["schemas"]["tax_mode"];
        /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
        unit_price: components["schemas"]["money"];
        /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
        unit_price_overrides?: components["schemas"]["unit_price_override"][];
        /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. If omitted, defaults to 1-100. */
        quantity?: components["schemas"]["price_quantity"];
        /** @description Your own structured key-value data. */
        custom_data?: components["schemas"]["custom_data"] | null;
        /** @description Product object for a non-catalog item to charge for. */
        product: components["schemas"]["transaction-subscription-product-create"];
      };
    };
    /**
     * Subscription ID
     * @description Unique Paddle ID for this subscription entity, prefixed with `sub_`.
     */
    subscription_id: string;
    /** Subscription item create with price */
    subscription_item_create_with_price: {
      /** @description Quantity to bill for. */
      quantity: number;
      /** @description Price object for a non-catalog item to bill for. Include a `product_id` to relate this non-catalog price to an existing catalog price. */
      price: components["schemas"]["transaction-price-create-with-product-id"];
    };
    /** Subscription item create with price */
    subscription_item_create_with_price_and_product: {
      /** @description Quantity to bill for. */
      quantity: number;
      /** @description Price object for a non-catalog item to charge for. Include a `product` object to create a non-catalog product for this non-catalog price. */
      price: components["schemas"]["transaction-price-create-with-product"];
    };
    /** Subscription item create with price id */
    subscription_item_create_with_price_id: {
      /** @description Quantity to bill for. */
      quantity: number;
      /** @description Paddle ID of an an existing catalog price to bill for. */
      price_id: components["schemas"]["price_id"];
    };
    /**
     * Subscription Management Urls
     * @description Customer portal deep links for this subscription.
     *
     *     Authenticated links are only returned when your API key has Customer portal session (Write) permission. For security, the `token` appended to authenticated links is temporary. You shouldn't store them.
     */
    subscription_management_urls: {
      /**
       * Format: uri
       * @description Link to the page for this subscription in the customer portal with the payment method update form pre-opened. Use as part of workflows to let customers update their payment details. `null` for manually-collected subscriptions.
       */
      update_payment_method?: string | null;
      /**
       * Format: uri
       * @description Link to the page for this subscription in the customer portal with the subscription cancellation form pre-opened. Use as part of cancel subscription workflows.
       */
      cancel: string;
    };
    /**
     * Next transaction
     * @description Preview of the next transaction for this subscription. May include prorated charges that aren't yet billed and one-time charges. `null` if the subscription is scheduled to cancel or pause.
     */
    subscription_next_transaction: {
      /** @description Billing period for the next transaction. */
      billing_period: components["schemas"]["time_period"];
      details: components["schemas"]["subscription_transaction_preview_details"];
      /** @description Preview of adjustments for the next transaction. */
      adjustments: components["schemas"]["adjustment-preview"][];
    };
    /**
     * Subscription On Payment Failure
     * @description How Paddle should handle changes made to a subscription or its items if the payment fails during update. If omitted, defaults to `prevent_change`.
     * @default prevent_change
     * @enum {string}
     */
    subscription_on_payment_failure: "prevent_change" | "apply_change";
    /**
     * Subscription On Resume
     * @description How Paddle should set the billing period for the subscription when resuming. If omitted, defaults to `start_new_billing_period`.
     * @default start_new_billing_period
     * @enum {string}
     */
    subscription_on_resume: "continue_existing_billing_period" | "start_new_billing_period";
    /**
     * Subscription transaction details (preview)
     * @description Calculated totals for a transaction preview, including discounts, tax, and currency conversion. Considered the source of truth for totals on a transaction preview.
     */
    subscription_recurring_transaction_details: {
      /** @description List of tax rates applied to this transaction preview. */
      readonly tax_rates_used: {
        /** @description Rate used to calculate tax for this transaction preview. */
        readonly tax_rate: string;
        /** @description Calculated totals for the tax applied to this transaction preview. */
        totals: components["schemas"]["totals"];
      }[];
      /** @description Breakdown of the total for a transaction preview. `fee` and `earnings` always return `null` for transaction previews. */
      totals: components["schemas"]["transaction_totals"];
      /** @description Information about line items for this transaction preview. Different from transaction preview `items` as they include totals calculated by Paddle. Considered the source of truth for line item totals. */
      line_items: (components["schemas"]["transaction_preview_line_item"] & {
        /** @description How proration was calculated for this item. */
        proration?: components["schemas"]["transaction_item_proration"] | null;
      })[];
    };
    /**
     * Subscription scheduled change
     * @description Change that's scheduled to be applied to a subscription. Use the pause subscription, cancel subscription, and resume subscription operations to create scheduled changes. `null` if no scheduled changes.
     */
    subscription_scheduled_change: {
      /**
       * ScheduledChangeAction
       * @description Kind of change that's scheduled to be applied to this subscription.
       * @enum {string}
       */
      readonly action: "cancel" | "pause" | "resume";
      /** @description RFC 3339 datetime string of when this scheduled change takes effect. */
      readonly effective_at: components["schemas"]["timestamp"];
      /** @description RFC 3339 datetime string of when a paused subscription should resume. Only used for `pause` scheduled changes. */
      readonly resume_at: components["schemas"]["timestamp"] | null;
    };
    /**
     * Subscription transaction details (preview)
     * @description Calculated totals for a transaction preview, including discounts, tax, and currency conversion. Considered the source of truth for totals on a transaction preview.
     */
    subscription_transaction_preview_details: {
      /** @description List of tax rates applied to this transaction preview. */
      readonly tax_rates_used: {
        /** @description Rate used to calculate tax for this transaction preview. */
        readonly tax_rate: string;
        /** @description Calculated totals for the tax applied to this transaction preview. */
        totals: components["schemas"]["totals"];
      }[];
      /** @description Breakdown of the total for a transaction preview. `fee` and `earnings` always return `null` for transaction previews. */
      totals: components["schemas"]["transaction_totals"];
      /** @description Information about line items for this transaction preview. Different from transaction preview `items` as they include totals calculated by Paddle. Considered the source of truth for line item totals. */
      line_items: (components["schemas"]["transaction_preview_line_item"] & {
        /** @description How proration was calculated for this item. */
        proration?: components["schemas"]["transaction_item_proration"] | null;
      })[];
    };
    /** SubscriptionUpdateItem */
    subscription_update_item: {
      /** @description Paddle ID for the price to add to this subscription, prefixed with `pri_`. */
      price_id: components["schemas"]["price_id"];
      /** @description Quantity of this item to add to the subscription. If updating an existing item and not changing the quantity, you may omit `quantity`. */
      quantity?: number;
    };
    /**
     * Proration billing mode
     * @description How Paddle should handle proration calculation for changes made to a subscription or its items. Required when making
     *     changes that impact billing.
     *
     *     For automatically-collected subscriptions, responses may take longer than usual if a proration billing mode that
     *     collects for payment immediately is used.
     * @enum {string}
     */
    subscription_update_proration_billing_mode:
      | "prorated_immediately"
      | "prorated_next_billing_period"
      | "full_immediately"
      | "full_next_billing_period"
      | "do_not_bill";
    /**
     * Tax category
     * @description Tax category for this product. Used for charging the correct rate of tax. Selected tax category must be enabled on your Paddle account.
     * @enum {string}
     */
    tax_category:
      | "digital-goods"
      | "ebooks"
      | "implementation-services"
      | "professional-services"
      | "saas"
      | "software-programming-services"
      | "standard"
      | "training-services"
      | "website-hosting";
    /**
     * Tax mode
     * @description How tax is calculated for this price.
     * @default account_setting
     * @enum {string}
     */
    tax_mode: "account_setting" | "external" | "internal";
    /** Time period */
    time_period: {
      /**
       * Format: date-time
       * @description RFC 3339 datetime string of when this period starts.
       */
      starts_at: components["schemas"]["timestamp"];
      /**
       * Format: date-time
       * @description RFC 3339 datetime string of when this period ends.
       */
      ends_at: components["schemas"]["timestamp"];
    };
    /**
     * Timestamp
     * Format: date-time
     * @description RFC 3339 datetime string.
     */
    timestamp: string;
    /**
     * Totals
     * @description Breakdown of a charge in the lowest denomination of a currency (e.g. cents for USD).
     */
    totals: {
      /** @description Subtotal before discount, tax, and deductions. If an item, unit price multiplied by quantity. */
      readonly subtotal: string;
      /** @description Total discount as a result of any discounts applied.
       *
       *     Except for percentage discounts, Paddle applies tax to discounts based on the line item `price.tax_mode`. If `price.tax_mode` for a line item is `internal`, Paddle removes tax from the discount applied. */
      readonly discount: string;
      /** @description Total tax on the subtotal. */
      readonly tax: string;
      /** @description Total after discount and tax. */
      readonly total: string;
    };
    /**
     * Totals Without Discount
     * @description Breakdown of a charge in the lowest denomination of a currency (e.g. cents for USD).
     */
    totals_without_discount: {
      /** @description Subtotal before tax, and deductions. If an item, unit price multiplied by quantity. */
      readonly subtotal: string;
      /** @description Total tax on the subtotal. */
      readonly tax: string;
      /** @description Total after tax. */
      readonly total: string;
    };
    /**
     * Transaction
     * @description Represents a transaction entity.
     */
    transaction: {
      readonly id: components["schemas"]["transaction_id"];
      status: components["schemas"]["status-transaction"];
      /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
      customer_id: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
      address_id: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
      currency_code: components["schemas"]["currency_code"];
      readonly origin: components["schemas"]["origin-transaction"];
      /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
      readonly subscription_id: components["schemas"]["subscription_id"] | null;
      /**
       * @deprecated
       * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
       */
      readonly invoice_id: string | null;
      /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
      invoice_number: components["schemas"]["document_number"] | null;
      /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
      collection_mode: components["schemas"]["collection_mode"];
      /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
      discount_id: components["schemas"]["discount_id"] | null;
      /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
      billing_details: components["schemas"]["billing_details"] | null;
      /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
      billing_period: components["schemas"]["time_period"] | null;
      /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
      items: components["schemas"]["transaction_item"][];
      readonly details: components["schemas"]["transaction_details"];
      /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
      readonly payments: components["schemas"]["transaction_payment_attempt"][];
      /**
       * TransactionCheckout
       * @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise.
       */
      checkout: {
        /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
        url: string | null;
      } | null;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
      readonly billed_at: components["schemas"]["timestamp"] | null;
      /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
      readonly revised_at: components["schemas"]["timestamp"] | null;
    };
    /**
     * TransactionCreate
     * @description Represents a transaction entity when creating transactions.
     */
    "transaction-create": {
      readonly id?: components["schemas"]["transaction_id"];
      /** @description Status of this transaction. You may set a transaction to `billed` when creating,
       *     or omit to let Paddle set the status. Transactions are created as `ready` if they have
       *     an `address_id`, `customer_id`, and `items`, otherwise they are created as `draft`.
       *
       *     Marking as `billed` when creating is typically used when working with manually-collected
       *     transactions as part of an invoicing workflow. Billed transactions cannot be updated, only canceled. */
      status?: components["schemas"]["status-transaction-create"];
      /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. If omitted, transaction status is `draft`. */
      customer_id?: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. Requires `customer_id`. If omitted, transaction status is `draft`. */
      address_id?: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. Requires `customer_id`.  */
      business_id?: components["schemas"]["business_id"] | null;
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
      /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
      currency_code?: components["schemas"]["currency_code"] | null;
      readonly origin?: components["schemas"]["origin-transaction"];
      /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
      readonly subscription_id?: components["schemas"]["subscription_id"] | null;
      /**
       * @deprecated
       * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
       */
      readonly invoice_id?: string | null;
      /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
      readonly invoice_number?: string | null;
      /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. If omitted, defaults to `automatic`. */
      collection_mode?: components["schemas"]["collection_mode"];
      /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
      discount_id?: components["schemas"]["discount_id"] | null;
      /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
      billing_details?: components["schemas"]["billing_details"] | null;
      /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
      billing_period?: components["schemas"]["time_period"] | null;
      /** @description List of items to charge for. You can charge for items that you've added to your catalog by passing the Paddle ID of an existing price entity, or you can charge for non-catalog items by passing a price object.
       *
       *     Non-catalog items can be for existing products, or you can pass a product object as part of your price to charge for a non-catalog product. */
      items: (
        | components["schemas"]["transaction_item_create_with_price_id"]
        | components["schemas"]["transaction_item_create_with_price"]
        | components["schemas"]["transaction_item_create_with_price_and_product"]
      )[];
      readonly details?: components["schemas"]["transaction_details"];
      /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
      readonly payments?: components["schemas"]["transaction_payment_attempt"][];
      /**
       * TransactionCheckout
       * @description Paddle Checkout details for this transaction. You may pass a URL when creating or updating an automatically-collected transaction, or when creating or updating a manually-collected transaction where `billing_details.enable_checkout` is `true`.
       */
      checkout?: {
        /** @description Checkout URL to use for the payment link for this transaction. Pass the URL for an approved domain, or omit to use your default payment URL.
         *
         *     Paddle returns a unique payment link composed of the URL passed or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
        url: string | null;
      } | null;
      readonly created_at?: components["schemas"]["created_at"];
      readonly updated_at?: components["schemas"]["updated_at"];
      /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
      readonly billed_at?: components["schemas"]["timestamp"] | null;
    };
    /**
     * TransactionIncludes
     * @description Represents a transaction entity with included entities.
     */
    "transaction-includes": components["schemas"]["transaction"] & {
      /** @description Address for this transaction. Reflects the entity at the time it was added to the transaction, or its revision if `revised_at` is not `null`. Returned when the `include` parameter is used with the `address` value and the transaction has an `address_id`. */
      address?: components["schemas"]["address"];
      /** @description List of adjustments for this transaction. Returned when the `include` parameter is used with the `adjustment` value and the transaction has adjustments. */
      adjustments?: components["schemas"]["adjustment"][];
      /** @description Object containing totals for all adjustments on a transaction. Returned when the `include` parameter is used with the `adjustments_totals` value. */
      adjustments_totals?: components["schemas"]["transaction_adjustments_totals_include"];
      /** @description Business for this transaction. Reflects the entity at the time it was added to the transaction, or its revision if `revised_at` is not `null`. Returned when the `include` parameter is used with the `business` value and the transaction has a `business_id`. */
      business?: components["schemas"]["business"];
      /** @description Customer for this transaction. Reflects the entity at the time it was added to the transaction, or its revision if `revised_at` is not `null`. Returned when the `include` parameter is used with the `customer` value and the transaction has a `customer_id`. */
      customer?: components["schemas"]["customer"];
      /** @description Discount for this transaction. Reflects the entity at the time it was added to the transaction. Returned when the `include` parameter is used with the `discount` value and the transaction has a `discount_id`. */
      discount?: components["schemas"]["discount"];
      readonly available_payment_methods?: components["schemas"]["payment_method_type"][];
    };
    /**
     * TransactionPreview
     * @description Represents a transaction entity when previewing transactions.
     */
    "transaction-preview": {
      /** @description Paddle ID of the customer that this transaction preview is for, prefixed with `ctm_`. */
      customer_id?: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of the address that this transaction preview is for, prefixed with `add_`. Send one of `address_id`, `customer_ip_address`, or the `address` object when previewing. */
      address_id?: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of the business that this transaction preview is for, prefixed with `biz_`. */
      business_id?: components["schemas"]["business_id"] | null;
      /** @description Supported three-letter ISO 4217 currency code. */
      currency_code?: components["schemas"]["currency_code"];
      /** @description Paddle ID of the discount applied to this transaction preview, prefixed with `dsc_`. */
      discount_id?: components["schemas"]["discount_id"] | null;
      /** @description IP address for this transaction preview. Send one of `address_id`, `customer_ip_address`, or the `address` object when previewing. */
      customer_ip_address?: string | null;
      /** @description Address for this transaction preview. Send one of `address_id`, `customer_ip_address`, or the `address` object when previewing. */
      address?: components["schemas"]["address-preview"] | null;
      /**
       * @description Whether trials should be ignored for transaction preview calculations.
       *
       *     By default, recurring items with trials are considered to have a zero charge when previewing. Set to `true` to disable this.
       * @default false
       */
      ignore_trials?: boolean;
      /** @description List of items to preview transaction calculations for. */
      items: components["schemas"]["transaction_preview_item"][];
      readonly details?: components["schemas"]["transaction_preview_details"];
      readonly available_payment_methods?: components["schemas"]["payment_method_type"][];
    };
    /**
     * TransactionPreviewCreate
     * @description Represents a transaction entity when previewing.
     */
    "transaction-preview-create": {
      /** @description Paddle ID of the customer that this transaction preview is for, prefixed with `ctm_`. */
      customer_id?: components["schemas"]["customer_id"] | null;
      /** @description Supported three-letter ISO 4217 currency code. */
      currency_code?: components["schemas"]["currency_code"] | null;
      /** @description Paddle ID of the discount applied to this transaction preview, prefixed with `dsc_`. */
      discount_id?: components["schemas"]["discount_id"] | null;
      /**
       * @description Whether trials should be ignored for transaction preview calculations.
       *
       *     By default, recurring items with trials are considered to have a zero charge when previewing. Set to `true` to disable this.
       * @default false
       */
      ignore_trials?: boolean;
      /** @description List of items to preview charging for. You can preview charging for items that you've added to your catalog by passing the Paddle ID of an existing price entity, or you can preview charging for non-catalog items by passing a price object.
       *
       *     Non-catalog items can be for existing products, or you can pass a product object as part of your price to preview charging for a non-catalog product. */
      items: (
        | components["schemas"]["transaction_preview_item_with_price_id"]
        | components["schemas"]["transaction_preview_item_with_price"]
        | components["schemas"]["transaction_preview_item_with_price_and_product"]
      )[];
    };
    /**
     * TransactionPreviewCreateAddress
     * @description Represents a transaction entity when previewing with an address object.
     */
    "transaction-preview-create-address": {
      /** @description Address for this transaction preview. */
      address: components["schemas"]["address-preview"];
    } & components["schemas"]["transaction-preview-create"];
    /**
     * TransactionPreviewCreateIP
     * @description Represents a transaction entity when previewing with an IP address.
     */
    "transaction-preview-create-ip-address": {
      /** @description IP address for this transaction preview. */
      customer_ip_address: string;
    } & components["schemas"]["transaction-preview-create"];
    /**
     * TransactionPreviewCreatePaddleIDs
     * @description Represents a transaction entity when previewing with existing Paddle IDs.
     */
    "transaction-preview-create-paddle-ids": {
      /** @description Paddle ID of the address that this transaction preview is for, prefixed with `add_`. Requires `customer_id`. */
      address_id: components["schemas"]["address_id"];
      /** @description Paddle ID of the business that this transaction preview is for, prefixed with `biz_`. */
      business_id?: components["schemas"]["business_id"] | null;
    } & components["schemas"]["transaction-preview-create"];
    /**
     * TransactionPriceCreateBase
     * @description Represents a price entity.
     */
    "transaction-price-create-base": {
      /** @description Internal description for this price, not shown to customers. Typically notes for your team. */
      description: string;
      /** @description Name of this price, shown to customers at checkout and on invoices. Typically describes how often the related product bills. */
      name?: string | null;
      /** @description How often this price should be charged. `null` if price is non-recurring (one-time). */
      billing_cycle?: components["schemas"]["duration"] | null;
      /** @description Trial period for the product related to this price. The billing cycle begins once the trial period is over. `null` for no trial period. Requires `billing_cycle`. */
      trial_period?: components["schemas"]["duration"] | null;
      tax_mode?: components["schemas"]["tax_mode"];
      /** @description Base price. This price applies to all customers, except for customers located in countries where you have `unit_price_overrides`. */
      unit_price: components["schemas"]["money"];
      /** @description List of unit price overrides. Use to override the base price with a custom price and currency for a country or group of countries. */
      unit_price_overrides?: components["schemas"]["unit_price_override"][];
      /** @description Limits on how many times the related product can be purchased at this price. Useful for discount campaigns. If omitted, defaults to 1-100. */
      quantity?: components["schemas"]["price_quantity"];
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
    };
    /** TransactionPriceCreateWithProduct */
    "transaction-price-create-with-product": components["schemas"]["transaction-price-create-base"] & {
      /** @description Product object for a non-catalog item to charge for. */
      product: components["schemas"]["transaction-subscription-product-create"];
    };
    /** TransactionPriceCreateWithProductID */
    "transaction-price-create-with-product-id": components["schemas"]["transaction-price-create-base"] & {
      /** @description Paddle ID for the product that this price is for, prefixed with `pro_`. */
      product_id: components["schemas"]["product_id"];
    };
    /**
     * TransactionRevise
     * @description Represents a customer information revision for a transaction.
     */
    "transaction-revise": {
      /**
       * TransactionRevisionCustomer
       * @description Revised customer information for this transaction.
       */
      customer: {
        /** @description Revised name of the customer for this transaction. */
        name: components["schemas"]["name"];
      };
      /**
       * TransactionRevisionBusiness
       * @description Revised business information for this transaction.
       */
      business: {
        /** @description Revised name of the business for this transaction. */
        name: components["schemas"]["name"];
        /** @description Revised tax or VAT number for this transaction. You can't remove a valid tax or VAT number, only replace it with another valid one. Paddle automatically creates an adjustment to refund any tax where applicable. */
        tax_identifier: string;
      };
      /**
       * TransactionRevisionAddress
       * @description Revised address information for this transaction.
       */
      address: {
        /** @description Revised first line of the address for this transaction. */
        first_line: string;
        /** @description Revised second line of the address for this transaction. */
        second_line: string | null;
        /** @description Revised city of the address for this transaction. */
        city: string;
        /** @description Revised state, county, or region of the address for this transaction. */
        region: string;
      };
    };
    /** TransactionSubscriptionProductCreate */
    "transaction-subscription-product-create": {
      /** @description Name of this product. */
      name: string;
      /** @description Short description for this product. */
      description?: string | null;
      tax_category: components["schemas"]["tax_category"];
      /** @description Image for this product. Included in the checkout and on some customer documents. */
      image_url?: null | string;
      /** @description Your own structured key-value data. */
      custom_data?: components["schemas"]["custom_data"] | null;
    };
    /**
     * TransactionUpdate
     * @description Represents a transaction entity when updating transactions.
     */
    "transaction-update": {
      readonly id: components["schemas"]["transaction_id"];
      /** @description Status of this transaction. You may set a transaction to `billed` or `canceled`. Billed transactions cannot be changed.
       *
       *     For manually-collected transactions, marking as `billed` is essentially issuing an invoice. */
      status: components["schemas"]["status-transaction"];
      /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
      customer_id: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
      address_id: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Your own structured key-value data. */
      custom_data: components["schemas"]["custom_data"] | null;
      /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
      currency_code: components["schemas"]["currency_code"] | null;
      origin: components["schemas"]["origin-transaction"];
      /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
      readonly subscription_id: components["schemas"]["subscription_id"] | null;
      /**
       * @deprecated
       * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
       */
      readonly invoice_id: string | null;
      /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
      readonly invoice_number: string | null;
      /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
      collection_mode: components["schemas"]["collection_mode"];
      /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
      discount_id: components["schemas"]["discount_id"] | null;
      /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
      billing_details: components["schemas"]["billing_details_update"] | null;
      /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
      billing_period: components["schemas"]["time_period"] | null;
      /** @description List of items on this transaction.
       *
       *     When making a request, each object must contain either a `price_id` or a `price` object, and a `quantity`.
       *
       *     Include a `price_id` to charge for an existing catalog item, or a `price` object to charge for a non-catalog item. */
      items: (
        | components["schemas"]["transaction_item_create_with_price_id"]
        | components["schemas"]["transaction_item_create_with_price"]
        | components["schemas"]["transaction_item_create_with_price_and_product"]
      )[];
      readonly details: components["schemas"]["transaction_details"];
      /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
      readonly payments: components["schemas"]["transaction_payment_attempt"][];
      /**
       * TransactionCheckout
       * @description Paddle Checkout details for this transaction. You may pass a URL when creating or updating an automatically-collected transaction, or when creating or updating a manually-collected transaction where `billing_details.enable_checkout` is `true`.
       */
      checkout: {
        /** @description Checkout URL to use for the payment link for this transaction. Pass the URL for an approved domain, or `null` to set to your default payment URL.
         *
         *     Paddle returns a unique payment link composed of the URL passed or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
        url: string | null;
      } | null;
      readonly created_at: components["schemas"]["created_at"];
      readonly updated_at: components["schemas"]["updated_at"];
      /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
      readonly billed_at: components["schemas"]["timestamp"] | null;
    };
    /**
     * transaction.billed
     * @description Occurs when a transaction is billed. Its `status` field changes to `billed` and `billed_at` is populated.
     *
     *     Marking a transaction as billed is typically used when working with manually-collected transactions to issue an
     *     invoice. It's not typically part of checkout workflows, where collection mode is automatic.
     *
     *     Transactions are marked as billed when:
     *
     *     * You update its status to `billed` using the API.
     *     * You send an invoice (a manually-collected transaction) using the Paddle dashboard.
     *
     *     Billed transactions get an invoice number. They're considered legal records, so they can't be deleted or changed.
     *
     *     [`transaction.updated`](https://developer.paddle.com/webhooks/transactions/transaction-updated) events occur immediately after to add:
     *
     *     * `invoice_number`, and `invoice_id` if not already present.
     *     * If manually-collected, the newly created `subscription_id` for any recurring items.
     */
    "transaction.billed": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.canceled
     * @description Occurs when a transaction is canceled. Its `status` field changes to `canceled`.
     *
     *     Marking a transaction as canceled is typically used when working with manually-collected transactions to say that an
     *     invoice was created in error. It's not typically part of checkout workflows, where collection mode is automatic.
     *
     *     Transactions are marked as canceled when:
     *
     *     * You update its status to `canceled` using the API.
     *     * You cancel an invoice (a manually-collected transaction) using the Paddle dashboard.
     */
    "transaction.canceled": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.completed
     * @description Occurs when a transaction is completed. Its status field changes to `completed`.
     *
     *     Transactions move to completed after they're `paid`. After a transaction is paid, Paddle starts completed transaction processing. This involves:
     *
     *     * Logging details of the successful payment against `transaction.payments[]`.
     *     * Adding information about fees, earnings, and totals for payouts to the transaction entity.
     *     * For automatically-collected transactions, creating a subscription for any recurring items and adding the related `subscription_id` to the transaction entity.
     *     * For automatically-collected transactions, adding an `invoice_number` and `invoice_id` to the transaction entity.
     *
     *     [`transaction.updated`](/webhooks/transactions/transaction-updated) occurs as Paddle updates a paid transaction.
     *
     *     When all processing is completed, a transaction is marked as completed and `transaction.completed` occurs.
     */
    "transaction.completed": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.created
     * @description Occurs when a transaction is created. Paddle creates a transaction when:
     *
     *     * Customers open checkout.
     *     * You create an invoice in the Paddle dashboard.
     *
     *     You may also create a transaction using the API:
     *
     *     * Create a manually-collected transaction to create and send an invoice.
     *     * Create an automatically-collected transaction and pass to a checkout to collect for payment.
     *
     *     Where a transaction has `items`, `customer_id`, and `address_id`,
     *     [`transaction.ready`](https://developer.paddle.com/webhooks/transactions/transaction-ready) occurs immediately after.
     */
    "transaction.created": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.paid
     * @description Occurs when a transaction is paid. Its status field changes to `paid`.
     *
     *     Transactions are paid when payment has been captured successfully, but Paddle hasn't yet fully processed the transaction internally.
     *
     *     For example:
     *
     *     * Payout totals may not be present.
     *     * Automatically-collected transactions for recurring items might not yet have a `subscription_id`.
     *     * Automatically-collected transactions might not yet have an `invoice_number`.
     *
     *     Transactions move to `completed` and [`transaction.completed`](/webhooks/transactions/transaction-completed) occurs when they're fully processed.
     */
    "transaction.paid": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.past_due
     * @description Occurs when a transaction becomes past due. Its `status` field changes to `past_due`.
     *
     *     * Automatically-collected transactions for subscription renewals become past due when a payment attempt fails.
     *     * Manually-collected transactions become past due when no payment has been received and the payment terms have elapsed.
     *
     *     The status against the related subscription for a transaction also changes to `past_due`, and
     *     [`subscription.past_due`](https://developer.paddle.com/webhooks/subscriptions/subscription-past-due) occurs.
     */
    "transaction.past_due": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.payment_failed
     * @description Occurs when a payment fails for a transaction. The `payments` array is updated with details of the payment attempt.
     *
     *     Typically happens for automatically-collected transactions, but may occur for manually-collected transactions
     *     (invoices) where a customer pays using Paddle Checkout and their payment is declined.
     *
     *     If related to a subscription renewal:
     *
     *     * The transaction status changes to `past_due` and [`transaction.past_due`](https://developer.paddle.com/webhooks/transactions/transaction-past-due)
     *     occurs.
     *     * The related subscription status changes to `past_due` and
     *     [`subscription.past_due`](https://developer.paddle.com/webhooks/subscriptions/subscription-past-due) occurs.
     *
     *     Manually-collected transactions are marked as `past_due` when the payment terms have elapsed.
     */
    "transaction.payment_failed": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.ready
     * @description Occurs when a transaction is ready to be billed. Its `status` field changes to `ready`.
     *
     *     Transactions are ready when they have all the required fields against them to be transitioned to `billed` or
     *     `completed`. This includes `items`, `customer_id`, and `address_id`. Paddle automatically marks transactions as
     *     `ready` when these fields are present.
     *
     *     When working with manually-collected transactions (invoices), [`transaction.updated`](https://developer.paddle.com/webhooks/transactions/transaction-updated)
     *     may occur immediately after to add `invoice_id` and `adjusted_totals`.
     */
    "transaction.ready": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.revised
     * @description Occurs when a transaction is revised.
     */
    "transaction.revised": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * transaction.updated
     * @description Occurs when a transaction is updated.
     *
     *     Specific events occur for status changes. `transaction.updated` may also occur after a status change events to add
     *     additional fields to the transaction after Paddle has completed internal processing for a transaction.
     *
     *     For example, [`transaction.billed`](https://developer.paddle.com/webhooks/transactions/transaction-billed) occurs when a transaction status
     *     changes to `billed`. `transaction.updated` occurs immediately after to add an `invoice_number`.
     */
    "transaction.updated": components["schemas"]["event"] & {
      readonly notification_id?: components["schemas"]["notification_id"];
      /** Transaction Notification */
      data?: {
        readonly id: components["schemas"]["transaction_id"];
        status: components["schemas"]["status-transaction"];
        /** @description Paddle ID of the customer that this transaction is for, prefixed with `ctm_`. */
        customer_id: components["schemas"]["customer_id"] | null;
        /** @description Paddle ID of the address that this transaction is for, prefixed with `add_`. */
        address_id: components["schemas"]["address_id"] | null;
        /** @description Paddle ID of the business that this transaction is for, prefixed with `biz_`. */
        business_id: components["schemas"]["business_id"] | null;
        /** @description Your own structured key-value data. */
        custom_data: components["schemas"]["custom_data"] | null;
        /** @description Supported three-letter ISO 4217 currency code. Must be `USD`, `EUR`, or `GBP` if `collection_mode` is `manual`. */
        currency_code: components["schemas"]["currency_code"];
        readonly origin: components["schemas"]["origin-transaction"];
        /** @description Paddle ID of the subscription that this transaction is for, prefixed with `sub_`. */
        readonly subscription_id: components["schemas"]["subscription_id"] | null;
        /**
         * @deprecated
         * @description Paddle ID of the invoice that this transaction is related to, prefixed with `inv_`. Used for compatibility with the Paddle Invoice API, which is now deprecated. This field is scheduled to be removed in the next version of the Paddle API.
         */
        readonly invoice_id: string | null;
        /** @description Invoice number for this transaction. Automatically generated by Paddle when you mark a transaction as `billed` where `collection_mode` is `manual`. */
        readonly invoice_number: string | null;
        /** @description How payment is collected for this transaction. `automatic` for checkout, `manual` for invoices. */
        collection_mode: components["schemas"]["collection_mode"];
        /** @description Paddle ID of the discount applied to this transaction, prefixed with `dsc_`. */
        discount_id: components["schemas"]["discount_id"] | null;
        /** @description Details for invoicing. Required if `collection_mode` is `manual`. */
        billing_details: components["schemas"]["billing_details"] | null;
        /** @description Time period that this transaction is for. Set automatically by Paddle for subscription renewals to describe the period that charges are for. */
        billing_period: components["schemas"]["time_period"] | null;
        /** @description List of items on this transaction. For calculated totals, use `details.line_items`. */
        items: components["schemas"]["transaction_item"][];
        readonly details: components["schemas"]["transaction_details"];
        /** @description List of payment attempts for this transaction, including successful payments. Sorted by `created_at` in descending order, so most recent attempts are returned first. */
        readonly payments: components["schemas"]["transaction_payment_attempt"][];
        /** @description Paddle Checkout details for this transaction. Returned for automatically-collected transactions and where `billing_details.enable_checkout` is `true` for manually-collected transactions; `null` otherwise. */
        checkout: {
          /** @description Paddle Checkout URL for this transaction, composed of the URL passed in the request or your default payment URL + `?_ptxn=` and the Paddle ID for this transaction. */
          url: string | null;
        } | null;
        readonly created_at: components["schemas"]["created_at"];
        readonly updated_at: components["schemas"]["updated_at"];
        /** @description RFC 3339 datetime string of when this transaction was marked as `billed`. `null` for transactions that aren't `billed` or `completed`. Set automatically by Paddle. */
        readonly billed_at: components["schemas"]["timestamp"] | null;
        /** @description RFC 3339 datetime string of when a transaction was revised. Revisions describe an update to customer information for a billed or completed transaction. `null` if not revised. Set automatically by Paddle. */
        readonly revised_at: components["schemas"]["timestamp"] | null;
      };
    };
    /**
     * Adjustment Totals
     * @description Breakdown of all the adjustments made against a transaction in the transaction currency.
     */
    transaction_adjustments_totals_include: {
      /** @description Total before tax. */
      readonly subtotal: string;
      /** @description Total tax on the subtotal. */
      readonly tax: string;
      /** @description Total after tax. */
      readonly total: string;
      /** @description Total fee taken by Paddle. */
      readonly fee: string;
      /** @description Total earnings. This is the subtotal minus the Paddle fee.
       *     For tax adjustments, this value is negative, which means a positive effect in the transaction earnings.
       *     This is because the fee is originally calculated from the transaction total, so if a tax adjustment is made,
       *     then the fee portion of it is returned.
       *     As a result, the earnings from all the adjustments performed could be either negative, positive or zero. */
      readonly earnings: string;
      /**
       * AdjustmentTotalsBreakdown
       * @description Breakdown of the total adjustments by adjustment action.
       */
      breakdown: {
        /** @description Total amount of credit adjustments. */
        credit: string;
        /** @description Total amount of refund adjustments. */
        refund: string;
        /** @description Total amount of chargeback adjustments. */
        chargeback: string;
      };
      /** @description Three-letter ISO 4217 currency code used for adjustments for this transaction. */
      currency_code: components["schemas"]["currency_code"];
    };
    /**
     * TransactionDetails
     * @description Calculated totals for a transaction, including proration, discounts, tax, and currency conversion. Considered the source of truth for totals on a transaction.
     */
    transaction_details: {
      /** @description List of tax rates applied for this transaction. */
      readonly tax_rates_used: {
        /** @description Rate used to calculate tax for this transaction. */
        readonly tax_rate: string;
        /** @description Calculated totals for the tax applied to this transaction. */
        totals: components["schemas"]["totals"];
      }[];
      totals: components["schemas"]["transaction_totals"];
      adjusted_totals: components["schemas"]["transaction_totals_adjusted"];
      /** @description Breakdown of the payout total for a transaction. `null` until the transaction is `completed`. Returned in your payout currency. */
      payout_totals: components["schemas"]["transaction_payout_totals"] | null;
      /** @description Breakdown of the payout total for a transaction after adjustments. `null` until the transaction is `completed`. */
      adjusted_payout_totals: components["schemas"]["transaction_payout_totals_adjusted"] | null;
      /** @description Information about line items for this transaction. Different from transaction `items` as they include totals calculated by Paddle. Considered the source of truth for line item totals. */
      line_items: ({
        readonly id?: components["schemas"]["transaction_item_id"];
      } & components["schemas"]["transaction_line_item"])[];
    };
    /**
     * Transaction ID
     * @description Unique Paddle ID for this transaction entity, prefixed with `txn_`.
     */
    transaction_id: string;
    /** TransactionItem */
    transaction_item: {
      /** @description Paddle ID for the price to add to this transaction, prefixed with `pri_`. */
      price_id?: components["schemas"]["price_id"];
      readonly price?: components["schemas"]["price"];
      /** @description Quantity of this item on the transaction. */
      quantity: number;
      /** @description How proration was calculated for this item. Populated when a transaction is created from a subscription change, where `proration_billing_mode` was `prorated_immediately` or `prorated_next_billing_period`. Set automatically by Paddle. */
      readonly proration?: components["schemas"]["transaction_item_proration"] | null;
    };
    /** Transaction item create (base) */
    transaction_item_create_base: {
      /** @description Quantity of this item on the transaction. */
      quantity: number;
      /** @description How proration was calculated for this item. Populated when a transaction is created from a subscription change, where `proration_billing_mode` was `prorated_immediately` or `prorated_next_billing_period`. Set automatically by Paddle. */
      readonly proration?: components["schemas"]["transaction_item_proration"] | null;
    };
    /** Transaction item create with price */
    transaction_item_create_with_price: components["schemas"]["transaction_item_create_base"] & {
      /** @description Price object for a non-catalog item to charge for. Include a `product_id` to relate this non-catalog price to an existing catalog price. */
      price: components["schemas"]["transaction-price-create-with-product-id"];
    };
    /** Transaction item create with price */
    transaction_item_create_with_price_and_product: components["schemas"]["transaction_item_create_base"] & {
      /** @description Price object for a non-catalog item to charge for. Include a `product` object to create a non-catalog product for this non-catalog price. */
      price: components["schemas"]["transaction-price-create-with-product"];
    };
    /** Transaction item create with price id */
    transaction_item_create_with_price_id: components["schemas"]["transaction_item_create_base"] & {
      /** @description Paddle ID of an existing catalog price to add to this transaction, prefixed with `pri_`. */
      price_id: components["schemas"]["price_id"];
    };
    /**
     * Transaction item ID
     * @description Unique Paddle ID for this transaction item, prefixed with `txnitm_`. Used when working with [adjustments](https://developer.paddle.com/build/transactions/create-transaction-adjustments).
     */
    transaction_item_id: string;
    /**
     * Proration
     * @description How proration was calculated for this item. Populated when a transaction is created from a subscription change, where `proration_billing_mode` was `prorated_immediately` or `prorated_next_billing_period`. Set automatically by Paddle.
     */
    transaction_item_proration: {
      /** @description Rate used to calculate proration. */
      readonly rate: string;
      /** @description Billing period that proration is based on. */
      readonly billing_period: components["schemas"]["time_period"];
    };
    /**
     * Transaction line item
     * @description Information about line items for this transaction. Different from transaction `items` as they include totals calculated by Paddle. Considered the source of truth for line item totals.
     */
    transaction_line_item: {
      /** @description Paddle ID for the price related to this transaction line item, prefixed with `pri_`. */
      readonly price_id: components["schemas"]["price_id"];
      /** @description Quantity of this transaction line item. */
      readonly quantity: number;
      /** @description How proration was calculated for this item. Populated when a transaction is created from a subscription change, where `proration_billing_mode` was `prorated_immediately` or `prorated_next_billing_period`. Set automatically by Paddle. */
      readonly proration: components["schemas"]["transaction_item_proration"] | null;
      /** @description Rate used to calculate tax for this transaction line item. */
      readonly tax_rate: string;
      /** @description Breakdown of the charge for one unit in the lowest denomination of a currency (e.g. cents for USD). */
      readonly unit_totals: components["schemas"]["totals"];
      readonly totals: components["schemas"]["totals"];
      /** @description Related product entity for this transaction line item price. Reflects the entity at the time it was added to the transaction. */
      readonly product: components["schemas"]["product"];
    };
    /** Transaction payment attempt */
    transaction_payment_attempt: {
      /** @description UUID for this payment attempt. */
      payment_attempt_id: string;
      /**
       * @deprecated
       * @description UUID for the stored payment method used for this payment attempt. Deprecated - use `payment_method_id` instead.
       */
      stored_payment_method_id: string;
      /** @description Paddle ID of the payment method used for this payment attempt, prefixed with `paymtd_`. */
      payment_method_id: components["schemas"]["payment_method_id"] | null;
      /** @description Amount for collection in the lowest denomination of a currency (e.g. cents for USD). */
      amount: string;
      status: components["schemas"]["status-payment_attempt"];
      /** @description Reason why a payment attempt failed. Returns `null` if payment captured successfully. */
      error_code: components["schemas"]["error_code"] | null;
      method_details: components["schemas"]["method_details"];
      created_at: components["schemas"]["created_at"];
      /** @description RFC 3339 datetime string of when this payment was captured. `null` if `status` is not `captured`. */
      captured_at: components["schemas"]["timestamp"] | null;
    };
    /**
     * PaymentMethodType
     * @description Type of payment method used for this payment attempt.
     * @enum {string}
     */
    transaction_payment_method_type:
      | "alipay"
      | "apple_pay"
      | "bancontact"
      | "card"
      | "google_pay"
      | "ideal"
      | "korea_local"
      | "offline"
      | "paypal"
      | "unknown"
      | "wire_transfer";
    /**
     * Transaction payout totals
     * @description Breakdown of the payout total for a transaction. `null` until the transaction is `completed`. Returned in your payout currency.
     */
    transaction_payout_totals: {
      /** @description Total before tax and fees. */
      subtotal: string;
      /** @description Total discount as a result of any discounts applied.
       *     Except for percentage discounts, Paddle applies tax to discounts based on the line item `price.tax_mode`. If `price.tax_mode` for a line item is `internal`, Paddle removes tax from the discount applied. */
      discount: string;
      /** @description Total tax on the subtotal. */
      tax: string;
      /** @description Total after tax. */
      total: string;
      /** @description Total credit applied to this transaction. This includes credits applied using a customer's credit balance and adjustments to a `billed` transaction. */
      credit: string;
      /** @description Additional credit generated from negative `details.line_items`. This credit is added to the customer balance. */
      credit_to_balance: string;
      /** @description Total due on a transaction after credits and any payments. */
      balance: string;
      /** @description Total due on a transaction after credits but before any payments. */
      grand_total: string;
      /** @description Total fee taken by Paddle for this payout. */
      fee: string;
      /** @description Total earnings for this payout. This is the subtotal minus the Paddle fee. */
      earnings: string;
      /** @description Three-letter ISO 4217 currency code used for the payout for this transaction. If your primary currency has changed, this reflects the primary currency at the time the transaction was billed. */
      currency_code: components["schemas"]["currency_code-payout"];
    };
    /**
     * Transaction payout totals (adjusted)
     * @description Breakdown of the payout total for a transaction after adjustments. `null` until the transaction is `completed`.
     */
    transaction_payout_totals_adjusted: {
      /** @description Total before tax and fees. */
      subtotal: string;
      /** @description Total tax on the subtotal. */
      tax: string;
      /** @description Total after tax. */
      total: string;
      /** @description Total fee taken by Paddle for this payout. */
      fee: string;
      /** @description Details of any chargeback fees incurred for this transaction. */
      chargeback_fee: {
        /** @description Chargeback fee converted into the payout currency. */
        amount: string;
        /** @description Chargeback fee before conversion to the payout currency. `null` when the chargeback fee is the same as the payout currency. */
        original: {
          /** @description Fee amount for this chargeback in the original currency. */
          amount: string;
          /** @description Three-letter ISO 4217 currency code for the original chargeback fee. */
          currency_code: components["schemas"]["currency_code-chargeback"];
        } | null;
      };
      /** @description Total earnings for this payout. This is the subtotal minus the Paddle fee, excluding chargeback fees. */
      earnings: string;
      /** @description Three-letter ISO 4217 currency code used for the payout for this transaction. If your primary currency has changed, this reflects the primary currency at the time the transaction was billed. */
      currency_code: components["schemas"]["currency_code-payout"];
    };
    /**
     * Transaction details (preview)
     * @description Calculated totals for a transaction preview, including discounts, tax, and currency conversion. Considered the source of truth for totals on a transaction preview.
     */
    transaction_preview_details: {
      /** @description List of tax rates applied to this transaction preview. */
      readonly tax_rates_used: {
        /** @description Rate used to calculate tax for this transaction preview. */
        readonly tax_rate: string;
        /** @description Calculated totals for the tax applied to this transaction preview. */
        totals: components["schemas"]["totals"];
      }[];
      /** @description Breakdown of the total for a transaction preview. `fee` and `earnings` always return `null` for transaction previews. */
      totals: components["schemas"]["transaction_totals"];
      /** @description Information about line items for this transaction preview. Different from transaction preview `items` as they include totals calculated by Paddle. Considered the source of truth for line item totals. */
      line_items: components["schemas"]["transaction_preview_line_item"][];
    };
    /** Transaction item (preview) */
    transaction_preview_item: components["schemas"]["transaction_preview_item_base"] & {
      readonly price: components["schemas"]["price-preview"];
    };
    /** Transaction item (preview - base) */
    transaction_preview_item_base: {
      /** @description Quantity of this item on the transaction. */
      quantity: number;
      /**
       * @description Whether this item should be included in totals for this transaction preview. Typically used to exclude one-time charges from calculations.
       * @default true
       */
      include_in_totals?: boolean;
      /** @description How proration was calculated for this item. `null` for transaction previews. */
      readonly proration?: components["schemas"]["transaction_item_proration"] | null;
    };
    /** Transaction item (preview) with price */
    transaction_preview_item_with_price: components["schemas"]["transaction_preview_item_base"] & {
      /** @description Price object for a non-catalog item to preview charging for. Include a `product_id` to relate this non-catalog price to an existing catalog price. */
      price: components["schemas"]["transaction-price-create-with-product-id"];
    };
    /** Transaction item (preview) with price */
    transaction_preview_item_with_price_and_product: components["schemas"]["transaction_preview_item_base"] & {
      /** @description Price object for a non-catalog item to preview charging for. Include a `product` object to create a non-catalog product for this non-catalog price. */
      price: components["schemas"]["transaction-price-create-with-product"];
    };
    /** Transaction item (preview) with price id */
    transaction_preview_item_with_price_id: components["schemas"]["transaction_preview_item_base"] & {
      /** @description Paddle ID of an existing catalog price to preview charging for, prefixed with `pri_`. */
      price_id: components["schemas"]["price_id"];
    };
    /**
     * Transaction line item (preview)
     * @description Information about line items for this transaction preview. Different from transaction preview `items` as they include totals calculated by Paddle. Considered the source of truth for line item totals.
     */
    transaction_preview_line_item: {
      /** @description Paddle ID for the price related to this transaction line item, prefixed with `pri_`.
       *     The value is null for custom prices being previewed. */
      readonly price_id: components["schemas"]["price_id"] | null;
      /** @description Quantity of this transaction line item. */
      readonly quantity: number;
      /** @description Rate used to calculate tax for this transaction line item. */
      readonly tax_rate: string;
      /** @description Breakdown of the charge for one unit in the lowest denomination of a currency (e.g. cents for USD). */
      readonly unit_totals: components["schemas"]["totals"];
      readonly totals: components["schemas"]["totals"];
      /** @description Related product entity for this transaction line item price. */
      readonly product: components["schemas"]["product-preview"];
      /** @description How proration was calculated for this item. */
      proration: components["schemas"]["transaction_item_proration"] | null;
    };
    /** Price preview (base) */
    transaction_pricing_preview_base: {
      /** @description Paddle ID of the customer that this preview is for, prefixed with `ctm_`. */
      customer_id: components["schemas"]["customer_id"] | null;
      /** @description Paddle ID of the address that this preview is for, prefixed with `add_`. Send one of `address_id`, `customer_ip_address`, or the `address` object when previewing. */
      address_id: components["schemas"]["address_id"] | null;
      /** @description Paddle ID of the business that this preview is for, prefixed with `biz_`. */
      business_id: components["schemas"]["business_id"] | null;
      /** @description Supported three-letter ISO 4217 currency code. */
      currency_code: components["schemas"]["currency_code"] | null;
      /** @description Paddle ID of the discount applied to this preview, prefixed with `dsc_`. */
      discount_id: components["schemas"]["discount_id"] | null;
      /** @description Address for this preview. Send one of `address_id`, `customer_ip_address`, or the `address` object when previewing. */
      address: components["schemas"]["address-preview"] | null;
      /** @description IP address for this transaction preview. Send one of `address_id`, `customer_ip_address`, or the `address` object when previewing. */
      customer_ip_address: string | null;
    };
    /**
     * Price preview details
     * @description Calculated totals for a price preview, including discounts, tax, and currency conversion.
     */
    transaction_pricing_preview_details: {
      line_items: components["schemas"]["transaction_pricing_preview_line_item"][];
    };
    /** Price preview item */
    transaction_pricing_preview_item: {
      /** @description Paddle ID for the price to add to this transaction, prefixed with `pri_`. */
      price_id?: components["schemas"]["price_id"];
      /** @description Quantity of the item to preview. */
      quantity: number;
    };
    /**
     * Price preview line item
     * @description Information about line items for this preview. Includes totals calculated by Paddle. Considered the source of truth for line item totals.
     */
    transaction_pricing_preview_line_item: {
      /** @description Related price entity for this preview line item. */
      price: components["schemas"]["price"];
      /** @description Quantity of this preview line item. */
      quantity: number;
      /** @description Rate used to calculate tax for this preview line item. */
      tax_rate: string;
      /** @description Breakdown of the charge for one unit in the lowest denomination of a currency (e.g. cents for USD). */
      unit_totals: components["schemas"]["totals"];
      /** @description Breakdown of the charge for one unit in the format of a given currency. */
      formatted_unit_totals: components["schemas"]["totals"];
      totals: components["schemas"]["totals"];
      /** @description The financial breakdown of a charge in the format of a given currency. */
      formatted_totals: components["schemas"]["totals"];
      /** @description Related product entity for this preview line item price. */
      product: components["schemas"]["product"];
      discounts: components["schemas"]["transaction_pricing_preview_line_item_discount"][];
    };
    /**
     * Price preview discounts
     * @description Array of discounts applied to this preview line item. Empty if no discounts applied.
     */
    transaction_pricing_preview_line_item_discount: {
      /** @description Related discount entity for this preview line item. */
      discount: components["schemas"]["discount"];
      /** @description Total amount discounted as a result of this discount. */
      total: string;
      /** @description Total amount discounted as a result of this discount in the format of a given currency. ' */
      formatted_total: string;
    };
    /** Price preview request */
    transaction_pricing_preview_request: components["schemas"]["transaction_pricing_preview_base"] & {
      /** @description List of items to preview price calculations for. */
      items: components["schemas"]["transaction_pricing_preview_item"][];
    };
    /** PricePreview */
    transaction_pricing_preview_response: components["schemas"]["transaction_pricing_preview_base"] & {
      readonly details?: components["schemas"]["transaction_pricing_preview_details"];
      readonly available_payment_methods?: components["schemas"]["payment_method_type"][];
    };
    /**
     * Transaction totals
     * @description Breakdown of the total for a transaction. These numbers can be negative when dealing with subscription updates that result in credit.
     */
    transaction_totals: components["schemas"]["totals"] & {
      /** @description Total credit applied to this transaction. This includes credits applied using a customer's credit balance and adjustments to a `billed` transaction. */
      credit?: string;
      /** @description Additional credit generated from negative `details.line_items`. This credit is added to the customer balance. */
      credit_to_balance?: string;
      /** @description Total due on a transaction after credits and any payments. */
      balance?: string;
      /** @description Total due on a transaction after credits but before any payments. */
      grand_total?: string;
      /** @description Total fee taken by Paddle for this transaction. `null` until the transaction is `completed` and the fee is processed. */
      fee?: string | null;
      /** @description Total earnings for this transaction. This is the total minus the Paddle fee. `null` until the transaction is `completed` and the fee is processed. */
      earnings?: string | null;
      /** @description Three-letter ISO 4217 currency code of the currency used for this transaction. */
      currency_code?: components["schemas"]["currency_code"];
    };
    /**
     * Transaction totals (adjusted)
     * @description Breakdown of the totals for a transaction after adjustments.
     */
    transaction_totals_adjusted: {
      /** @description Subtotal before discount, tax, and deductions. If an item, unit price multiplied by quantity. */
      subtotal: string;
      /** @description Total tax on the subtotal. */
      tax: string;
      /** @description Total after tax. */
      total: string;
      /** @description Total due after credits but before any payments. */
      grand_total: string;
      /** @description Total fee taken by Paddle for this transaction. `null` until the transaction is `completed` and the fee is processed. */
      fee: string | null;
      /** @description Total earnings for this transaction. This is the total minus the Paddle fee.
       *     `null` until the transaction is `completed` and the fee is processed. */
      earnings: string | null;
      /** @description Three-letter ISO 4217 currency code of the currency used for this transaction. */
      currency_code: components["schemas"]["currency_code"];
    };
    /**
     * Underlying details
     * @description Information about the underlying payment method used to pay. Populated for payment methods that offer multiple payment options, like `korea_local`.
     */
    underlying_details: {
      readonly korea_local: components["schemas"]["korea_local_underlying_details"] | null;
    };
    /** Unit price override */
    unit_price_override: {
      /** @description Supported two-letter ISO 3166-1 alpha-2 country code. Customers located in the listed countries are charged the override price. */
      country_codes: components["schemas"]["country_code"][];
      /** @description Override price. This price applies to customers located in the countries for this unit price override. */
      unit_price: components["schemas"]["money"];
    };
    /**
     * Subscription preview update summary
     * @description Impact of this subscription change. Includes whether the change results in a charge or credit, and totals for prorated amounts.
     */
    update_summary: {
      /** @description Details of any credit adjustments created for this update. Paddle creates adjustments against existing transactions when prorating. */
      credit: components["schemas"]["money"];
      /** @description Details of the transaction to be created for this update. Paddle creates a transaction to bill for new charges. */
      charge: components["schemas"]["money"];
      /**
       * UpdateSummaryResult
       * @description Details of the result of credits and charges. Where the total of any credit adjustments is greater than the total charge, the result is a prorated credit; otherwise, the result is a prorated charge.
       */
      result: {
        /**
         * UpdateSummaryResultAction
         * @description Whether the subscription change results in a prorated credit or a charge.
         * @enum {string}
         */
        action: "credit" | "charge";
        /** @description Amount representing the result of this update, either a charge or a credit. */
        amount: string;
        /** @description Three-letter ISO 4217 currency code for the transaction or adjustment. */
        currency_code: components["schemas"]["currency_code"];
      };
    };
    /**
     * Updated at
     * Format: date-time
     * @description RFC 3339 datetime string of when this entity was updated. Set automatically by Paddle.
     */
    updated_at: string;
  };
  responses: {
    /** @description An error occurred. Check the `type`, `code`, and `detail` in the returned error object for more information.
     *
     *     Validation errors include an array of `errors` with information about which fields failed validation. */
    error: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        "application/json": components["schemas"]["error"];
      };
    };
  };
  parameters: {
    /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
    "Paddle-Signature": string;
    /** @description Return entities for the specified action. */
    action_adjustment_query:
      | "chargeback"
      | "chargeback_reverse"
      | "chargeback_warning"
      | "chargeback_warning_reverse"
      | "credit"
      | "credit_reverse"
      | "refund";
    /** @description Determine whether returned entities are active (`true`) or not (`false`). */
    active_notification_settings_query: boolean;
    /** @description Paddle ID of the address entity to work with. */
    address_id_path: string;
    /** @description Return entities related to the specified address. Use a comma-separated list to specify multiple address IDs. */
    address_id_query: string[];
    /** @description Paddle ID of the adjustment entity to work with. */
    adjustment_id_path: string;
    /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
    after_query: string;
    /** @description Return entities billed at a specific time. Pass an RFC 3339 datetime string, or use `[LT]` (less than), `[LTE]` (less than or equal to), `[GT]` (greater than), or `[GTE]` (greater than or equal to) operators. For example, `billed_at=2023-04-18T17:03:26` or `billed_at[LT]=2023-04-18T17:03:26`. */
    billed_at_query: string;
    /** @description Paddle ID of the business entity to work with. */
    business_id_path: string;
    /** @description Return entities that match the discount code. Use a comma-separated list to specify multiple discount codes. */
    code_query: string[];
    /** @description Return entities that match the specified collection mode. */
    collection_mode_query: "automatic" | "manual";
    /** @description Return entities created at a specific time. Pass an RFC 3339 datetime string, or use `[LT]` (less than), `[LTE]` (less than or equal to), `[GT]` (greater than), or `[GTE]` (greater than or equal to) operators. For example, `created_at=2023-04-18T17:03:26` or `created_at[LT]=2023-04-18T17:03:26`. */
    created_at_query: string;
    /** @description Return entities that match the currency code. Use a comma-separated list to specify multiple currency codes. */
    currency_code_query: string[];
    /** @description Paddle ID of the customer entity to work with. */
    customer_id_path: string;
    /** @description Return entities related to the specified customer. Use a comma-separated list to specify multiple customer IDs. */
    customer_id_query: string[];
    /** @description Paddle ID of the discount entity to work with. */
    discount_id_path: string;
    /** @description Determine whether the generated URL should download the PDF as an attachment saved locally, or open it inline in the browser.
     *
     *     Default: `attachment`. */
    disposition_query: "attachment" | "inline";
    /** @description Return entities that exactly match the specified email address. Use a comma-separated list to specify multiple email addresses. Recommended for precise matching of email addresses. */
    email_query: string[];
    /** @description Return entities that contain the Paddle ID specified. Pass a transaction, customer, or subscription ID. */
    filter_notification_query: string;
    /** @description Return entities from a specific time. Pass an RFC 3339 datetime string. */
    from_query: string;
    /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
    id_query: string[];
    /** @description Include related entities in the response. */
    include_price_query: "product"[];
    /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
    include_product_query: "prices"[];
    /** @description Include related entities in the response. */
    include_simulation_events_query: "events"[];
    /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
    include_subscription_query: ("next_transaction" | "recurring_transaction_details")[];
    /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
    include_transaction_query: (
      | "address"
      | "adjustments"
      | "adjustments_totals"
      | "available_payment_methods"
      | "business"
      | "customer"
      | "discount"
    )[];
    /** @description Return entities that match the invoice number. Use a comma-separated list to specify multiple invoice numbers. */
    invoice_number_query: string[];
    /** @description Return entities that match the specified mode. */
    mode_discount_query: "custom" | "standard";
    /** @description Paddle ID of the notification entity to work with. */
    notification_id_path: string;
    /** @description Paddle ID of the notification setting entity (notification destination) to work with. */
    notification_setting_id_path: string;
    /** @description Return entities related to the specified notification destination. Use a comma-separated list to specify multiple notification destination IDs. */
    notification_setting_id_query: string[];
    /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
     *
     *     Valid fields for ordering: `id`. */
    order_by_query: string;
    /** @description Return entities related to the specified origin. Use a comma-separated list to specify multiple origins. */
    origin_query: (
      | "api"
      | "subscription_charge"
      | "subscription_payment_method_change"
      | "subscription_recurring"
      | "subscription_update"
      | "web"
    )[];
    /** @description Paddle ID of the payment method entity to work with. */
    payment_method_id_path: string;
    /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
     *
     *     Default: `10`; Maximum: `50`. */
    per_page_adjustment_query: number;
    /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
     *
     *     Default: `200`; Maximum: `200`. */
    per_page_notification_settings_query: number;
    /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
     *
     *     Default: `50`; Maximum: `200`. */
    per_page_query: number;
    /** @description Set how many entities are returned per page. */
    per_page_transaction_query: number;
    /** @description Paddle ID of the price entity to work with. */
    price_id_path: string;
    /** @description Return entities related to the specified price. Use a comma-separated list to specify multiple price IDs. */
    price_id_query: string[];
    /** @description Paddle ID of the product entity to work with. */
    product_id_path: string;
    /** @description Return entities related to the specified product. Use a comma-separated list to specify multiple product IDs. */
    product_id_query: string[];
    /** @description Determine whether returned entities are for recurring prices (`true`) or one-time prices (`false`). */
    recurring_query: boolean;
    /** @description Paddle ID of the replay entity to work with. */
    replay_id_path: string;
    /** @description Paddle ID of the report entity. */
    report_id_path: string;
    /** @description Return subscriptions that have a scheduled change. Use a comma-separated list to specify multiple scheduled change actions. */
    scheduled_change_action_query: ("cancel" | "pause" | "resume")[];
    /** @description Return entities that match a search query. */
    search_query: string;
    /** @description Paddle ID of the simulation event entity to work with. */
    simulation_event_id_path: string;
    /** @description Paddle ID of the simulation entity to work with. */
    simulation_id_path: string;
    /** @description Paddle ID of the simulation run entity to work with. */
    simulation_run_id_path: string;
    /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
    status_adjustment_query: ("approved" | "pending_approval" | "rejected" | "reversed")[];
    /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
    status_discount_query: ("active" | "archived")[];
    /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
    status_notification_query: ("delivered" | "failed" | "needs_retry" | "not_attempted")[];
    /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
    status_query: ("active" | "archived")[];
    /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
    status_report_query: ("pending" | "ready" | "failed" | "expired")[];
    /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
    status_subscription_query: ("active" | "canceled" | "past_due" | "paused" | "trialing")[];
    /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
    status_transaction_query: (
      | "draft"
      | "ready"
      | "billed"
      | "paid"
      | "completed"
      | "canceled"
      | "past_due"
    )[];
    /** @description Return entities related to the specified subscription. Use a comma-separated list to specify multiple subscription IDs. Pass `null` to return entities that aren't related to any subscription. */
    subscription_id_nullable_query: string[];
    /** @description Paddle ID of the subscription entity to work with. */
    subscription_id_path: string;
    /** @description Return entities related to the specified subscription. Use a comma-separated list to specify multiple subscription IDs. */
    subscription_id_query: string[];
    /** @description Return entities that support being presented at checkout (`true`) or not (`false`). */
    supports_checkout_query: boolean;
    /** @description Return entities that match the specified tax category. Use a comma-separated list to specify multiple tax categories. */
    tax_category_query: (
      | "digital-goods"
      | "ebooks"
      | "implementation-services"
      | "professional-services"
      | "saas"
      | "software-programming-services"
      | "standard"
      | "training-services"
      | "website-hosting"
    )[];
    /** @description Return entities up to a specific time. Pass an RFC 3339 datetime string. */
    to_query: string;
    /** @description Return entities that match the specified traffic source. */
    traffic_source_query: "platform" | "simulation" | "all";
    /** @description Paddle ID of the transaction entity to work with. */
    transaction_id_path: string;
    /** @description Return entities related to the specified transaction. Use a comma-separated list to specify multiple transaction IDs. */
    transaction_id_query: string[];
    /** @description Return items that match the specified type. */
    type_catalog_query: "custom" | "standard";
    /** @description Return entities updated at a specific time. Pass an RFC 3339 datetime string, or use `[LT]` (less than), `[LTE]` (less than or equal to), `[GT]` (greater than), or `[GTE]` (greater than or equal to) operators. For example, `updated_at=2023-04-18T17:03:26` or `updated_at[LT]=2023-04-18T17:03:26`. */
    updated_at_query: string;
  };
  requestBodies: never;
  headers: {
    /** @description Identifier for this version of the resource. */
    Etag: string;
    /** @description Date and time when this resource expires. */
    Expires: string;
    /** @description Unique ID for the request relating to this response. Provide this when contacting Paddle support about a specific request. */
    "Request-Id": string;
  };
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  "list-products": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
        include?: components["parameters"]["include_product_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_query"];
        /** @description Return entities that match the specified tax category. Use a comma-separated list to specify multiple tax categories. */
        tax_category?: components["parameters"]["tax_category_query"];
        /** @description Return items that match the specified type. */
        type?: components["parameters"]["type_catalog_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["product-includes"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-product": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["product-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["product"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-product": {
    parameters: {
      query?: {
        /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
        include?: components["parameters"]["include_product_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the product entity to work with. */
        product_id: components["parameters"]["product_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["product-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-product": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the product entity to work with. */
        product_id: components["parameters"]["product_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["product-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["product"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-prices": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Include related entities in the response. */
        include?: components["parameters"]["include_price_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities related to the specified product. Use a comma-separated list to specify multiple product IDs. */
        product_id?: components["parameters"]["product_id_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_query"];
        /** @description Determine whether returned entities are for recurring prices (`true`) or one-time prices (`false`). */
        recurring?: components["parameters"]["recurring_query"];
        /** @description Return items that match the specified type. */
        type?: components["parameters"]["type_catalog_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["price-includes"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-price": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["price-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["price"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-price": {
    parameters: {
      query?: {
        /** @description Include related entities in the response. */
        include?: components["parameters"]["include_price_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the price entity to work with. */
        price_id: components["parameters"]["price_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["price-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-price": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the price entity to work with. */
        price_id: components["parameters"]["price_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["price-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["price"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-transactions": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return entities billed at a specific time. Pass an RFC 3339 datetime string, or use `[LT]` (less than), `[LTE]` (less than or equal to), `[GT]` (greater than), or `[GTE]` (greater than or equal to) operators. For example, `billed_at=2023-04-18T17:03:26` or `billed_at[LT]=2023-04-18T17:03:26`. */
        billed_at?: components["parameters"]["billed_at_query"];
        /** @description Return entities that match the specified collection mode. */
        collection_mode?: components["parameters"]["collection_mode_query"];
        /** @description Return entities created at a specific time. Pass an RFC 3339 datetime string, or use `[LT]` (less than), `[LTE]` (less than or equal to), `[GT]` (greater than), or `[GTE]` (greater than or equal to) operators. For example, `created_at=2023-04-18T17:03:26` or `created_at[LT]=2023-04-18T17:03:26`. */
        created_at?: components["parameters"]["created_at_query"];
        /** @description Return entities related to the specified customer. Use a comma-separated list to specify multiple customer IDs. */
        customer_id?: components["parameters"]["customer_id_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
        include?: components["parameters"]["include_transaction_query"];
        /** @description Return entities that match the invoice number. Use a comma-separated list to specify multiple invoice numbers. */
        invoice_number?: components["parameters"]["invoice_number_query"];
        /** @description Return entities related to the specified origin. Use a comma-separated list to specify multiple origins. */
        origin?: components["parameters"]["origin_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_transaction_query"];
        /** @description Return entities related to the specified subscription. Use a comma-separated list to specify multiple subscription IDs. Pass `null` to return entities that aren't related to any subscription. */
        subscription_id?: components["parameters"]["subscription_id_nullable_query"];
        /** @description Set how many entities are returned per page. */
        per_page?: components["parameters"]["per_page_transaction_query"];
        /** @description Return entities updated at a specific time. Pass an RFC 3339 datetime string, or use `[LT]` (less than), `[LTE]` (less than or equal to), `[GT]` (greater than), or `[GTE]` (greater than or equal to) operators. For example, `updated_at=2023-04-18T17:03:26` or `updated_at[LT]=2023-04-18T17:03:26`. */
        updated_at?: components["parameters"]["updated_at_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          "Request-Id": components["headers"]["Request-Id"];
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction-includes"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-transaction": {
    parameters: {
      query?: {
        /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
        include?: components["parameters"]["include_transaction_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["transaction-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "preview-prices": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["transaction_pricing_preview_request"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction_pricing_preview_response"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "preview-transaction-create": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json":
          | components["schemas"]["transaction-preview-create"]
          | components["schemas"]["transaction-preview-create-address"]
          | components["schemas"]["transaction-preview-create-ip-address"]
          | components["schemas"]["transaction-preview-create-paddle-ids"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction-preview"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-transaction": {
    parameters: {
      query?: {
        /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
        include?: components["parameters"]["include_transaction_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the transaction entity to work with. */
        transaction_id: components["parameters"]["transaction_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-transaction": {
    parameters: {
      query?: {
        /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
        include?: components["parameters"]["include_transaction_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the transaction entity to work with. */
        transaction_id: components["parameters"]["transaction_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["transaction-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "revise-transaction": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the transaction entity to work with. */
        transaction_id: components["parameters"]["transaction_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["transaction-revise"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-adjustments": {
    parameters: {
      query?: {
        /** @description Return entities for the specified action. */
        action?: components["parameters"]["action_adjustment_query"];
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return entities related to the specified customer. Use a comma-separated list to specify multiple customer IDs. */
        customer_id?: components["parameters"]["customer_id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `10`; Maximum: `50`. */
        per_page?: components["parameters"]["per_page_adjustment_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_adjustment_query"];
        /** @description Return entities related to the specified subscription. Use a comma-separated list to specify multiple subscription IDs. */
        subscription_id?: components["parameters"]["subscription_id_query"];
        /** @description Return entities related to the specified transaction. Use a comma-separated list to specify multiple transaction IDs. */
        transaction_id?: components["parameters"]["transaction_id_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["adjustment"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-adjustment": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["adjustment-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["adjustment"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-adjustment-credit-note": {
    parameters: {
      query?: {
        /** @description Determine whether the generated URL should download the PDF as an attachment saved locally, or open it inline in the browser.
         *
         *     Default: `attachment`. */
        disposition?: components["parameters"]["disposition_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the adjustment entity to work with. */
        adjustment_id: components["parameters"]["adjustment_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Adjustment credit note PDF */
            data: {
              /** @description URL of the requested resource. */
              url: string;
            };
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-credit-balances": {
    parameters: {
      query?: {
        /** @description Return entities that match the currency code. Use a comma-separated list to specify multiple currency codes. */
        currency_code?: components["parameters"]["currency_code_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["credit_balance"][];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-customers": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return entities that exactly match the specified email address. Use a comma-separated list to specify multiple email addresses. Recommended for precise matching of email addresses. */
        email?: components["parameters"]["email_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that match a search query. */
        search?: components["parameters"]["search_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-customer": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["customer-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-customer": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-customer": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["customer-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-addresses": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that match a search query. */
        search?: components["parameters"]["search_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["address"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-address": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["address-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["address"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-address": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the address entity to work with. */
        address_id: components["parameters"]["address_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["address"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-address": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the address entity to work with. */
        address_id: components["parameters"]["address_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["address-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["address"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "generate-customer-authentication-token": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer_authentication_token"];
            meta: components["schemas"]["meta"];
          };
        };
      };
    };
  };
  "list-businesses": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that match a search query. */
        search?: components["parameters"]["search_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["business"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-business": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["business-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["business"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-business": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the business entity to work with. */
        business_id: components["parameters"]["business_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["business"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-business": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the business entity to work with. */
        business_id: components["parameters"]["business_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["business-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["business"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-customer-payment-methods": {
    parameters: {
      query?: {
        /** @description Return entities related to the specified address. Use a comma-separated list to specify multiple address IDs. */
        address_id?: components["parameters"]["address_id_query"];
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that support being presented at checkout (`true`) or not (`false`). */
        supports_checkout?: components["parameters"]["supports_checkout_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer-payment-method"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-customer-payment-method": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the payment method entity to work with. */
        payment_method_id: components["parameters"]["payment_method_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer-payment-method"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "delete-customer-payment-method": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
        /** @description Paddle ID of the payment method entity to work with. */
        payment_method_id: components["parameters"]["payment_method_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          "Request-Id": components["headers"]["Request-Id"];
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components["responses"]["error"];
    };
  };
  "create-customer-portal-session": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the customer entity to work with. */
        customer_id: components["parameters"]["customer_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["customer-portal-session-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["customer-portal-session"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-notification-settings": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `200`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_notification_settings_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Determine whether returned entities are active (`true`) or not (`false`). */
        active?: components["parameters"]["active_notification_settings_query"];
        /** @description Return entities that match the specified traffic source. */
        traffic_source?: components["parameters"]["traffic_source_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["notification_setting"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-notification-setting": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["notification_setting-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["notification_setting"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-notification-setting": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification setting entity (notification destination) to work with. */
        notification_setting_id: components["parameters"]["notification_setting_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["notification_setting"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "delete-notification-setting": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification setting entity (notification destination) to work with. */
        notification_setting_id: components["parameters"]["notification_setting_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No Content */
      204: {
        headers: {
          "Request-Id": components["headers"]["Request-Id"];
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components["responses"]["error"];
    };
  };
  "update-notification-setting": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification setting entity (notification destination) to work with. */
        notification_setting_id: components["parameters"]["notification_setting_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["notification_setting-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["notification_setting"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-event-types": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["event_type"][];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-events": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["event"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-notifications": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return entities related to the specified notification destination. Use a comma-separated list to specify multiple notification destination IDs. */
        notification_setting_id?: components["parameters"]["notification_setting_id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that match a search query. */
        search?: components["parameters"]["search_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_notification_query"];
        /** @description Return entities that contain the Paddle ID specified. Pass a transaction, customer, or subscription ID. */
        filter?: components["parameters"]["filter_notification_query"];
        /** @description Return entities up to a specific time. Pass an RFC 3339 datetime string. */
        to?: components["parameters"]["to_query"];
        /** @description Return entities from a specific time. Pass an RFC 3339 datetime string. */
        from?: components["parameters"]["from_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["notification"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-notification": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification entity to work with. */
        notification_id: components["parameters"]["notification_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["notification"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-notification-logs": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the notification entity to work with. */
        notification_id: components["parameters"]["notification_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["notification_log"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "replay-notification": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the notification entity to work with. */
        notification_id: components["parameters"]["notification_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: {
              notification_id: components["schemas"]["notification_id"];
            };
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-simulation-types": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation_type"][];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-simulations": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return entities related to the specified notification destination. Use a comma-separated list to specify multiple notification destination IDs. */
        notification_setting_id?: components["parameters"]["notification_setting_id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-simulation": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["simulation-create"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-simulation": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-simulation": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["simulation-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-simulation-runs": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Include related entities in the response. */
        include?: components["parameters"]["include_simulation_events_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation-run-includes"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-simulation-run": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation-run"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-simulation-run": {
    parameters: {
      query?: {
        /** @description Include related entities in the response. */
        include?: components["parameters"]["include_simulation_events_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation-run-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-simulations-events": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation-event"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-simulation-event": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
        /** @description Paddle ID of the simulation event entity to work with. */
        simulation_event_id: components["parameters"]["simulation_event_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation-event"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "replay-simulation-run-event": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the simulation entity to work with. */
        simulation_id: components["parameters"]["simulation_id_path"];
        /** @description Paddle ID of the simulation run entity to work with. */
        simulation_run_id: components["parameters"]["simulation_run_id_path"];
        /** @description Paddle ID of the simulation event entity to work with. */
        simulation_event_id: components["parameters"]["simulation_event_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Accepted */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["simulation-event"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-ip-addresses": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          Etag: components["headers"]["Etag"];
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** IPAddress */
            data: {
              /** @description List of Paddle IPv4 CIDRs. */
              ipv4_cidrs: string[];
            };
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-transaction-invoice": {
    parameters: {
      query?: {
        /** @description Determine whether the generated URL should download the PDF as an attachment saved locally, or open it inline in the browser.
         *
         *     Default: `attachment`. */
        disposition?: components["parameters"]["disposition_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the transaction entity to work with. */
        transaction_id: components["parameters"]["transaction_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          Expires: components["headers"]["Expires"];
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Transaction invoice PDF */
            data: {
              /** @description URL of the requested resource. */
              url: string;
            };
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-discounts": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return entities that match the discount code. Use a comma-separated list to specify multiple discount codes. */
        code?: components["parameters"]["code_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_discount_query"];
        /** @description Return entities that match the specified mode. */
        mode?: components["parameters"]["mode_discount_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["discount"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-discount": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["discount-create"];
      };
    };
    responses: {
      /** @description OK */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["discount"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-discount": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the discount entity to work with. */
        discount_id: components["parameters"]["discount_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["discount"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-discount": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the discount entity to work with. */
        discount_id: components["parameters"]["discount_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["discount"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["discount"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-subscription": {
    parameters: {
      query?: {
        /** @description Include related entities in the response. Use a comma-separated list to specify multiple entities. */
        include?: components["parameters"]["include_subscription_query"];
      };
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription-includes"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "update-subscription": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["subscription-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-subscriptions": {
    parameters: {
      query?: {
        /** @description Return entities related to the specified address. Use a comma-separated list to specify multiple address IDs. */
        address_id?: components["parameters"]["address_id_query"];
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Return entities that match the specified collection mode. */
        collection_mode?: components["parameters"]["collection_mode_query"];
        /** @description Return entities related to the specified customer. Use a comma-separated list to specify multiple customer IDs. */
        customer_id?: components["parameters"]["customer_id_query"];
        /** @description Return only the IDs specified. Use a comma-separated list to get multiple entities. */
        id?: components["parameters"]["id_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities related to the specified price. Use a comma-separated list to specify multiple price IDs. */
        price_id?: components["parameters"]["price_id_query"];
        /** @description Return subscriptions that have a scheduled change. Use a comma-separated list to specify multiple scheduled change actions. */
        scheduled_change_action?: components["parameters"]["scheduled_change_action_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_subscription_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "cancel-subscription": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @default next_billing_period */
          effective_from: components["schemas"]["effective_from_nullable"];
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "pause-subscription": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": {
          /** @default next_billing_period */
          effective_from: components["schemas"]["effective_from_nullable"];
          /** @description RFC 3339 datetime string of when the paused subscription should resume. Omit to pause indefinitely until resumed. */
          resume_at: components["schemas"]["timestamp"] | null;
          /** @default start_new_billing_period */
          on_resume: components["schemas"]["subscription_on_resume"];
        };
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "resume-subscription": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json":
          | {
              /** @description When this scheduled change should take effect from. RFC 3339 datetime string of when the subscription should resume.
               *
               *     Valid where subscriptions are `active` with a scheduled change to pause, or where they have the status of `paused`. */
              effective_from: components["schemas"]["timestamp"];
              /** @default start_new_billing_period */
              on_resume?: components["schemas"]["subscription_on_resume"];
            }
          | {
              /**
               * @description When this subscription change should take effect from. You can pass `immediately` to resume immediately.
               *
               *     Valid where subscriptions have the status of `paused`.
               *
               *     Defaults to `immediately` if omitted.
               * @default immediately
               * @enum {string|null}
               */
              effective_from: "immediately" | null;
              /** @default start_new_billing_period */
              on_resume?: components["schemas"]["subscription_on_resume"];
            }
          | null
          | Record<string, never>;
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "activate-subscription": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-subscription-update-payment-method-transaction": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["transaction"] & {
              /** @description Related customer for this transaction. Only returned if the API key has a Customers (Read) permission. */
              customer?: components["schemas"]["customer"];
              /** @description Related address for this transaction. Only returned if the API key has an Addresses (Read) permission. */
              address?: components["schemas"]["address"];
              /** @description Related business for this transaction. Only returned if a business exists for this transaction and the API key has a Businesses (Read) permission. */
              business?: components["schemas"]["business"];
              /** @description Related discount for this transaction. Only returned if a discount exists for this transaction and the API key has a Discounts (Read) permission. */
              discount?: components["schemas"]["discount"];
              /** @description Related adjustments for this transaction. Only returned if adjustments exist for this transaction and the API key has an Adjustments (Read) permission. */
              adjustments?: components["schemas"]["adjustment"][];
              /** @description Object containing totals for all adjustments on this transaction. Only returned if the API key has an Adjustments (Read) permission. */
              adjustments_totals?: components["schemas"]["transaction_adjustments_totals_include"];
              /** @description List of payment methods available for this transaction. */
              available_payment_methods?: components["schemas"]["payment_method_type"][];
            };
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "preview-subscription-update": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["subscription-update"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription-preview"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-subscription-charge": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["subscription-charge"];
      };
    };
    responses: {
      /** @description OK */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "preview-subscription-charge": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the subscription entity to work with. */
        subscription_id: components["parameters"]["subscription_id_path"];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["subscription-charge"];
      };
    };
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["subscription-preview"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "list-reports": {
    parameters: {
      query?: {
        /** @description Return entities after the specified Paddle ID when working with paginated endpoints. Used in the `meta.pagination.next` URL in responses for list operations. */
        after?: components["parameters"]["after_query"];
        /** @description Order returned entities by the specified field and direction (`[ASC]` or `[DESC]`). For example, `?order_by=id[ASC]`.
         *
         *     Valid fields for ordering: `id`. */
        order_by?: components["parameters"]["order_by_query"];
        /** @description Set how many entities are returned per page. Paddle returns the maximum number of results if a number greater than the maximum is requested. Check `meta.pagination.per_page` in the response to see how many were returned.
         *
         *     Default: `50`; Maximum: `200`. */
        per_page?: components["parameters"]["per_page_query"];
        /** @description Return entities that match the specified status. Use a comma-separated list to specify multiple status values. */
        status?: components["parameters"]["status_report_query"];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["report"][];
            meta: components["schemas"]["meta-paginated"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "create-report": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        "application/json": components["schemas"]["report"];
      };
    };
    responses: {
      /** @description Created */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["report"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-report-csv": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the report entity. */
        report_id: components["parameters"]["report_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns a download url for the report */
      200: {
        headers: {
          Expires: components["headers"]["Expires"];
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            /** Report CSV */
            data: {
              /** @description URL of the requested resource. */
              url: string;
            };
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "get-report": {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Paddle ID of the report entity. */
        report_id: components["parameters"]["report_id_path"];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description OK */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          "application/json": {
            data: components["schemas"]["report"];
            meta: components["schemas"]["meta"];
          };
        };
      };
      default: components["responses"]["error"];
    };
  };
  "address-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["address.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "address-imported": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["address.imported"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "address-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["address.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "adjustment-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["adjustment.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "adjustment-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["adjustment.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "api-key-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["api_key.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "api-key-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["api_key.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "api-key-expired": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["api_key.expired"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "api-key-expiring": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["api_key.expiring"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "api-key-revoked": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["api_key.revoked"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "business-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["business.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "business-imported": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["business.imported"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "business-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["business.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "customer-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["customer.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "customer-imported": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["customer.imported"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "customer-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["customer.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "discount-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["discount.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "discount-imported": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["discount.imported"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "discount-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["discount.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "payment-method-saved": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["payment_method.saved"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "payment-method-deleted": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["payment_method.deleted"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "payout-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["payout.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "payout-paid": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["payout.paid"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "price-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["price.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "price-imported": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["price.imported"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "price-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["price.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "product-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["product.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "product-imported": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["product.imported"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "product-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["product.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "report-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["report.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "report-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["report.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-activated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.activated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-canceled": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.canceled"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-past_due": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.past_due"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-imported": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.imported"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-paused": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.paused"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-resumed": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.resumed"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-trialing": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.trialing"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "subscription-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["subscription.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-billed": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.billed"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-canceled": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.canceled"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-completed": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.completed"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-created": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.created"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-paid": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.paid"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-past_due": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.past_due"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-payment_failed": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.payment_failed"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-ready": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.ready"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-updated": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.updated"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  "transaction-revised": {
    parameters: {
      query?: never;
      header: {
        /** @description Signature for this request. Use to verify that webhooks come from Paddle. */
        "Paddle-Signature": components["parameters"]["Paddle-Signature"];
      };
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["transaction.revised"];
      };
    };
    responses: {
      /** @description Respond with an HTTP 200 status code within 5 seconds to let Paddle know that you successfully received the message.
       *
       *     If your server sends another kind of status code or doesn't respond, Paddle automatically retries using an exponential backoff schedule. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
